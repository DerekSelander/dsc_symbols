|| __DATA.__data _SKAChannelManagerErrorRetryIntervalKey
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseChannel
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseInvitedUser
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabasePendingPublishRequest
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseReceivedInvitation
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseRemovedUser
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseStatus
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseSubscriptionAssertion
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseTransientSubscriptionHistory
|| __DATA.__objc_data _OBJC_CLASS_$_SKAGeneratedEncryptionKey
|| __DATA.__objc_data _OBJC_CLASS_$_SKAStatusPublishingServiceClient
|| __DATA.__objc_data _OBJC_CLASS_$_SKAStatusPublishingServiceClientConnection
|| __DATA.__objc_data _OBJC_CLASS_$_SKAStatusUnencryptedEnvelope
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseChannel
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseInvitedUser
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabasePendingPublishRequest
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseReceivedInvitation
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseRemovedUser
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseStatus
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseSubscriptionAssertion
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseTransientSubscriptionHistory
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAGeneratedEncryptionKey
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAStatusPublishingServiceClient
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAStatusPublishingServiceClientConnection
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAStatusUnencryptedEnvelope
|| __DATA_CONST.__const _SKAAccountProviderErrorDomain
|| __DATA_CONST.__const _SKAChannelManagerErrorDomain
|| __DATA_CONST.__const _SKPushManagerErrorDomain
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAAccountProvider
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAChannelManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKADatabaseManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKADatabaseProvider
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAInvitationManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAMessagingProvider
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAPushManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusEncryptionManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusPublishingManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusReceivingManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusServer
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusSubscriptionManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusSubscriptionServiceClient
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusSubscriptionServiceClientConnection
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKASystemMonitor
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAAccountProvider
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAChannelManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKADatabaseManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKADatabaseProvider
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAInvitationManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAMessagingProvider
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAPushManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusEncryptionManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusPublishingManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusReceivingManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusServer
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusSubscriptionManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusSubscriptionServiceClient
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusSubscriptionServiceClientConnection
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKASystemMonitor
__ Accounts: _OBJC_CLASS_$_ACAccountStore
__ ApplePushService: _APSConnectionOverrideNamedDelegatePort
__ ApplePushService: _APSEnvironmentDevelopment
__ ApplePushService: _APSEnvironmentProduction
__ ApplePushService: _OBJC_CLASS_$_APSConnection
__ AuthKit: _OBJC_CLASS_$_AKAppleIDAuthenticationContext
__ AuthKit: _OBJC_CLASS_$_AKAppleIDAuthenticationController
__ BiomeStreams: _OBJC_CLASS_$_BMStreams
__ BiomeStreams: _OBJC_CLASS_$_BMUserStatusChangeEvent
__ CloudKit: _OBJC_CLASS_$_CKContainer
__ CloudKit: _OBJC_CLASS_$_CKContainerID
__ CoreData: _NSInferMappingModelAutomaticallyOption
__ CoreData: _NSMigratePersistentStoresAutomaticallyOption
__ CoreData: _NSPersistentHistoryTrackingKey
__ CoreData: _NSPersistentStoreRemoteChangeNotification
__ CoreData: _NSPersistentStoreRemoteChangeNotificationPostOptionKey
__ CoreData: _NSSQLiteStoreType
__ CoreData: _OBJC_CLASS_$_NSFetchRequest
__ CoreData: _OBJC_CLASS_$_NSManagedObject
__ CoreData: _OBJC_CLASS_$_NSManagedObjectModel
__ CoreData: _OBJC_CLASS_$_NSPersistentCloudKitContainer
__ CoreData: _OBJC_CLASS_$_NSPersistentCloudKitContainerOptions
__ CoreData: _OBJC_CLASS_$_NSPersistentHistoryChangeRequest
__ CoreData: _OBJC_CLASS_$_NSPersistentHistoryToken
__ CoreData: _OBJC_CLASS_$_NSPersistentHistoryTransaction
__ CoreData: _OBJC_CLASS_$_NSPersistentStoreDescription
__ CoreData: _OBJC_METACLASS_$_NSManagedObject
__ CoreFoundation: _CFPreferencesCopyAppValue
__ CoreFoundation: _CFPreferencesGetAppBooleanValue
__ CoreFoundation: _CFPreferencesSetAppValue
__ CoreFoundation: _OBJC_CLASS_$_NSArray
__ CoreFoundation: _OBJC_CLASS_$_NSConstantArray
__ CoreFoundation: _OBJC_CLASS_$_NSData
__ CoreFoundation: _OBJC_CLASS_$_NSDate
__ CoreFoundation: _OBJC_CLASS_$_NSDictionary
__ CoreFoundation: _OBJC_CLASS_$_NSMutableArray
__ CoreFoundation: _OBJC_CLASS_$_NSMutableDictionary
__ CoreFoundation: _OBJC_CLASS_$_NSMutableOrderedSet
__ CoreFoundation: _OBJC_CLASS_$_NSMutableSet
__ CoreFoundation: _OBJC_CLASS_$_NSSet
__ CoreFoundation: _OBJC_CLASS_$_NSUserDefaults
__ CoreFoundation: ___CFConstantStringClassReference
__ CoreFoundation: ___NSArray0__struct
__ CoreFoundation: ___kCFBooleanFalse
__ CoreFoundation: ___kCFBooleanTrue
__ FTServices: _OBJC_CLASS_$_FTMessageDelivery_APS
__ FTServices: _OBJC_CLASS_$_FTShareChannelMessage
__ Foundation: _NSClassFromString
__ Foundation: _NSCocoaErrorDomain
__ Foundation: _NSDebugDescriptionErrorKey
__ Foundation: _NSLocalizedDescriptionKey
__ Foundation: _NSStringFromClass
__ Foundation: _NSStringFromSelector
__ Foundation: _NSUnderlyingErrorKey
__ Foundation: _OBJC_CLASS_$_NSBundle
__ Foundation: _OBJC_CLASS_$_NSCompoundPredicate
__ Foundation: _OBJC_CLASS_$_NSConstantIntegerNumber
__ Foundation: _OBJC_CLASS_$_NSError
__ Foundation: _OBJC_CLASS_$_NSFileManager
__ Foundation: _OBJC_CLASS_$_NSHashTable
__ Foundation: _OBJC_CLASS_$_NSJSONSerialization
__ Foundation: _OBJC_CLASS_$_NSKeyedArchiver
__ Foundation: _OBJC_CLASS_$_NSKeyedUnarchiver
__ Foundation: _OBJC_CLASS_$_NSMapTable
__ Foundation: _OBJC_CLASS_$_NSMutableIndexSet
__ Foundation: _OBJC_CLASS_$_NSMutableString
__ Foundation: _OBJC_CLASS_$_NSNotificationCenter
__ Foundation: _OBJC_CLASS_$_NSNumber
__ Foundation: _OBJC_CLASS_$_NSPredicate
__ Foundation: _OBJC_CLASS_$_NSPropertyListSerialization
__ Foundation: _OBJC_CLASS_$_NSSortDescriptor
__ Foundation: _OBJC_CLASS_$_NSString
__ Foundation: _OBJC_CLASS_$_NSUUID
__ Foundation: _OBJC_CLASS_$_NSXPCConnection
__ Foundation: _OBJC_CLASS_$_NSXPCListener
__ IDS: _IDSCopyIDForEmailAddress
__ IDS: _IDSCopyIDForPhoneNumber
__ IDS: _IDSCopyRawAddressForDestination
__ IDS: _IDSSendMessageOptionFromIDKey
__ IDS: _OBJC_CLASS_$_IDSIDQueryController
__ IDS: _OBJC_CLASS_$_IDSServerBag
__ IDS: _OBJC_CLASS_$_IDSService
__ IDS: _OBJC_CLASS_$_IDSURI
__ IDS: __IDSCopyCallerID
__ MessageProtection: _OBJC_CLASS_$_MPStatusKitIncomingRatchet
__ MessageProtection: _OBJC_CLASS_$_MPStatusKitOutgoingRatchet
__ MobileKeyBag: _MKBDeviceUnlockedSinceBoot
__ MobileKeyBag: _kMobileKeyBagLockStatusNotifyToken
__ ProtocolBuffer: _OBJC_CLASS_$_PBCodable
__ ProtocolBuffer: _OBJC_CLASS_$_PBRequest
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._bytes
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._error
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._length
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._pos
__ ProtocolBuffer: _OBJC_METACLASS_$_PBCodable
__ ProtocolBuffer: _OBJC_METACLASS_$_PBRequest
__ ProtocolBuffer: _PBDataWriterWriteBOOLField
__ ProtocolBuffer: _PBDataWriterWriteDataField
__ ProtocolBuffer: _PBDataWriterWriteInt32Field
__ ProtocolBuffer: _PBDataWriterWriteStringField
__ ProtocolBuffer: _PBDataWriterWriteSubmessage
__ ProtocolBuffer: _PBDataWriterWriteUint32Field
__ ProtocolBuffer: _PBDataWriterWriteUint64Field
__ ProtocolBuffer: _PBReaderPlaceMark
__ ProtocolBuffer: _PBReaderReadData
__ ProtocolBuffer: _PBReaderReadString
__ ProtocolBuffer: _PBReaderRecallMark
__ ProtocolBuffer: _PBReaderSkipValueWithTag
__ PushKit: _OBJC_CLASS_$_PKPublicChannel
__ StatusKit: _OBJC_CLASS_$_SKHandle
__ StatusKit: _OBJC_CLASS_$_SKHandleInvitability
__ StatusKit: _OBJC_CLASS_$_SKInvitationPayload
__ StatusKit: _OBJC_CLASS_$_SKPublishedStatus
__ StatusKit: _OBJC_CLASS_$_SKStatusPayload
__ StatusKit: _OBJC_CLASS_$_SKStatusPublishRequest
__ StatusKit: _OBJC_CLASS_$_SKStatusPublishingDaemonConnection
__ StatusKit: _OBJC_CLASS_$_SKStatusSubscriptionDaemonConnection
__ StatusKit: _OBJC_CLASS_$_SKStatusSubscriptionMetadata
__ StatusKit: _OBJC_CLASS_$_SKSubscriptionValidationTokens
__ StatusKit: _SKStatusPublishingErrorDomain
__ StatusKit: _SKStatusSubscriptionErrorDomain
__ libSystem.B.dylib: _CC_SHA256
__ libSystem.B.dylib: _XPC_ACTIVITY_ALLOW_BATTERY
__ libSystem.B.dylib: _XPC_ACTIVITY_CHECK_IN
__ libSystem.B.dylib: _XPC_ACTIVITY_INTERVAL
__ libSystem.B.dylib: _XPC_ACTIVITY_INTERVAL_1_DAY
__ libSystem.B.dylib: _XPC_ACTIVITY_PRIORITY
__ libSystem.B.dylib: _XPC_ACTIVITY_PRIORITY_MAINTENANCE
__ libSystem.B.dylib: _XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY
__ libSystem.B.dylib: __Block_object_assign
__ libSystem.B.dylib: __Block_object_dispose
__ libSystem.B.dylib: __NSConcreteGlobalBlock
__ libSystem.B.dylib: __NSConcreteStackBlock
__ libSystem.B.dylib: __Unwind_Resume
__ libSystem.B.dylib: ___stack_chk_fail
__ libSystem.B.dylib: ___stack_chk_guard
__ libSystem.B.dylib: __dispatch_main_q
__ libSystem.B.dylib: __os_activity_create
__ libSystem.B.dylib: __os_activity_current
__ libSystem.B.dylib: __os_feature_enabled_impl
__ libSystem.B.dylib: __os_log_debug_impl
__ libSystem.B.dylib: __os_log_error_impl
__ libSystem.B.dylib: __os_log_fault_impl
__ libSystem.B.dylib: __os_log_impl
__ libSystem.B.dylib: _arc4random_uniform
__ libSystem.B.dylib: _dispatch_after
__ libSystem.B.dylib: _dispatch_assert_queue$V2
__ libSystem.B.dylib: _dispatch_async
__ libSystem.B.dylib: _dispatch_once
__ libSystem.B.dylib: _dispatch_queue_attr_make_with_autorelease_frequency
__ libSystem.B.dylib: _dispatch_queue_attr_make_with_qos_class
__ libSystem.B.dylib: _dispatch_queue_create
__ libSystem.B.dylib: _dispatch_sync
__ libSystem.B.dylib: _dispatch_time
__ libSystem.B.dylib: _notify_is_valid_token
__ libSystem.B.dylib: _notify_register_dispatch
__ libSystem.B.dylib: _os_log_create
__ libSystem.B.dylib: _os_log_type_enabled
__ libSystem.B.dylib: _os_transaction_create
__ libSystem.B.dylib: _os_unfair_lock_lock
__ libSystem.B.dylib: _os_unfair_lock_unlock
__ libSystem.B.dylib: _strlen
__ libSystem.B.dylib: _xpc_activity_copy_criteria
__ libSystem.B.dylib: _xpc_activity_get_state
__ libSystem.B.dylib: _xpc_activity_register
__ libSystem.B.dylib: _xpc_activity_set_criteria
__ libSystem.B.dylib: _xpc_dictionary_create
__ libSystem.B.dylib: _xpc_dictionary_set_bool
__ libSystem.B.dylib: _xpc_dictionary_set_int64
__ libSystem.B.dylib: _xpc_dictionary_set_string
__ libSystem.B.dylib: _xpc_equal
__ libobjc.A.dylib: _OBJC_CLASS_$_NSObject
__ libobjc.A.dylib: _OBJC_METACLASS_$_NSObject
__ libobjc.A.dylib: ___objc_personality_v0
__ libobjc.A.dylib: __objc_empty_cache
__ libobjc.A.dylib: _objc_alloc
__ libobjc.A.dylib: _objc_alloc_init
__ libobjc.A.dylib: _objc_autorelease
__ libobjc.A.dylib: _objc_autoreleasePoolPop
__ libobjc.A.dylib: _objc_autoreleasePoolPush
__ libobjc.A.dylib: _objc_autoreleaseReturnValue
__ libobjc.A.dylib: _objc_copyWeak
__ libobjc.A.dylib: _objc_destroyWeak
__ libobjc.A.dylib: _objc_enumerationMutation
__ libobjc.A.dylib: _objc_initWeak
__ libobjc.A.dylib: _objc_loadWeakRetained
__ libobjc.A.dylib: _objc_msgSend
__ libobjc.A.dylib: _objc_msgSendSuper2
__ libobjc.A.dylib: _objc_opt_class
__ libobjc.A.dylib: _objc_opt_isKindOfClass
__ libobjc.A.dylib: _objc_opt_respondsToSelector
__ libobjc.A.dylib: _objc_opt_self
__ libobjc.A.dylib: _objc_release
__ libobjc.A.dylib: _objc_retain
__ libobjc.A.dylib: _objc_retainAutorelease
__ libobjc.A.dylib: _objc_retainAutoreleaseReturnValue
__ libobjc.A.dylib: _objc_retainAutoreleasedReturnValue
__ libobjc.A.dylib: _objc_storeStrong
__ libobjc.A.dylib: _objc_storeWeak
__ libobjc.A.dylib: _objc_sync_enter
__ libobjc.A.dylib: _objc_sync_exit
__ libobjc.A.dylib: _objc_unsafeClaimAutoreleasedReturnValue
SKAStatusEncryptionManager : NSObject <SKAStatusEncryptionManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAInvitationManaging> *invitationManager
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusEncryptionManager logger]

  // instance methods
  -[SKAStatusEncryptionManager _deserializeBinaryPlistDictionaryData:]
  -[SKAStatusEncryptionManager databaseManager]
  -[SKAStatusEncryptionManager encodeStatusPayload:statusUniqueIdentifier:dateCreated:currentServerTime:channel:]
  -[SKAStatusEncryptionManager _decryptPayloadData:withIncomingRatchet:withRatchetIndex:signatureData:]
  -[SKAStatusEncryptionManager .cxx_destruct]
  -[SKAStatusEncryptionManager _decryptPayload:withRatchetIndex:signatureData:channel:]
  -[SKAStatusEncryptionManager encryptionValidationTokenForChannel:]
  -[SKAStatusEncryptionManager decryptStatusPayloadFromStatusEnvelopeData:channel:]
  -[SKAStatusEncryptionManager invitationManager]
  -[SKAStatusEncryptionManager extractEnvelopeFromStatusEnvelopeData:]
  -[SKAStatusEncryptionManager _serializeDictionaryAsBinaryPlist:]
  -[SKAStatusEncryptionManager _mostRecentIncomingRatchetForChannel:]
  -[SKAStatusEncryptionManager _encryptPayload:channel:]
  -[SKAStatusEncryptionManager initWithDatabaseManager:invitationManager:]


SKAStatusUnencryptedEnvelope : NSObject
 @property  NSDictionary *envelopeDictionary
 @property  NSString *statusUniqueIdentifier
 @property  NSDate *datePublished
 @property  NSDate *dateCreated

  // instance methods
  -[SKAStatusUnencryptedEnvelope .cxx_destruct]
  -[SKAStatusUnencryptedEnvelope dateCreated]
  -[SKAStatusUnencryptedEnvelope envelopeDictionary]
  -[SKAStatusUnencryptedEnvelope initWithEnvelopeDictionary:]
  -[SKAStatusUnencryptedEnvelope datePublished]
  -[SKAStatusUnencryptedEnvelope statusUniqueIdentifier]
  -[SKAStatusUnencryptedEnvelope setEnvelopeDictionary:]


SKAInvitationManager : NSObject <SKAInvitationManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAMessagingProviding> *messagingProvider
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAAccountProviding> *accountProvider
 @property  NSObject<OS_dispatch_queue> *backgroundCleanupQueue
 @property  <SKAInvitationManagingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAInvitationManager logger]
  +[SKAInvitationManager _invalidInvitedHandlesError]
  +[SKAInvitationManager _invalidSenderHandleError]
  +[SKAInvitationManager _noPersonalChannelErrorForStatusTypeIdentifier:]
  +[SKAInvitationManager _keyRollFailedErrorWithUnderlyingError:]
  +[SKAInvitationManager _unableToFindAnyExistingInvitationToDeleteError]
  +[SKAInvitationManager _unableToFindExistingInvitationForHandlesError:]

  // instance methods
  -[SKAInvitationManager channelManager]
  -[SKAInvitationManager revokeInvitationFromPersonalChannelWithStatusTypeIdentifier:forHandles:completion:]
  -[SKAInvitationManager databaseManager]
  -[SKAInvitationManager messagingProvider]
  -[SKAInvitationManager setMessagingProvider:]
  -[SKAInvitationManager isHandleInviteable:fromHandle:completion:]
  -[SKAInvitationManager .cxx_destruct]
  -[SKAInvitationManager setDatabaseManager:]
  -[SKAInvitationManager _ratchetEncryptionKeyForwardOrKeyRollForPersonalChannel:databaseContext:invitationWasSentViaKeyRoll:error:]
  -[SKAInvitationManager sendInvitationForPersonalChannelWithStatusTypeIdentifier:toHandles:fromSenderHandle:withInvitationPayload:completion:]
  -[SKAInvitationManager setDelegate:]
  -[SKAInvitationManager _validateInvitedHandles:]
  -[SKAInvitationManager revokeAllInvitationsFromPersonalChannelWithStatusTypeIdentifier:completion:]
  -[SKAInvitationManager initWithMessagingProvider:databaseManager:accountProvider:channelManager:]
  -[SKAInvitationManager _validateInvitedHandle:]
  -[SKAInvitationManager _sendInvitationMessageForChannel:toInvitedUsers:subscriptionKeys:error:]
  -[SKAInvitationManager accountProvider]
  -[SKAInvitationManager rollPersonalChannelWithStatusTypeIdentifier:completion:]
  -[SKAInvitationManager backgroundCleanupQueue]
  -[SKAInvitationManager _rollEncryptionKeyForChannel:databaseContext:error:]
  -[SKAInvitationManager rollEncryptionKeyForPersonalChannelWithStatusTypeIdentifier:error:]
  -[SKAInvitationManager _updateOrCreateInvitedUserWithHandle:senderHandle:onChannel:withInvitationPayload:databaseContext:]
  -[SKAInvitationManager setAccountProvider:]
  -[SKAInvitationManager setBackgroundCleanupQueue:]
  -[SKAInvitationManager delegate]
  -[SKAInvitationManager setChannelManager:]
  -[SKAInvitationManager _createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAInvitationManager handleIncomingInvitationMessage:fromHandle:toHandle:messageGuid:]
  -[SKAInvitationManager _shouldReauthForError:]
  -[SKAInvitationManager _findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAInvitationManager resolveSenderHandleWithPreferredSenderHandle:]
  -[SKAInvitationManager _isHandleInviteable:completion:]
  -[SKAInvitationManager fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:]
  -[SKAInvitationManager _addInvitedHandles:senderHandle:toDatabaseForPersonalChannel:withInvitationPayload:databaseContext:]


SharedChannelCreateRequest : PBRequest <NSCopying>
 @property  BOOL hasChannelTopic
 @property  NSString *channelTopic
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelOwnershipType
 @property  int channelOwnershipType

  // instance methods
  -[SharedChannelCreateRequest mergeFrom:]
  -[SharedChannelCreateRequest .cxx_destruct]
  -[SharedChannelCreateRequest dictionaryRepresentation]
  -[SharedChannelCreateRequest writeTo:]
  -[SharedChannelCreateRequest isEqual:]
  -[SharedChannelCreateRequest copyTo:]
  -[SharedChannelCreateRequest readFrom:]
  -[SharedChannelCreateRequest setChannelTopic:]
  -[SharedChannelCreateRequest copyWithZone:]
  -[SharedChannelCreateRequest channelTopic]
  -[SharedChannelCreateRequest authCredential]
  -[SharedChannelCreateRequest setAuthCredential:]
  -[SharedChannelCreateRequest hasChannelTopic]
  -[SharedChannelCreateRequest hasAuthCredential]
  -[SharedChannelCreateRequest channelOwnershipType]
  -[SharedChannelCreateRequest setChannelOwnershipType:]
  -[SharedChannelCreateRequest setHasChannelOwnershipType:]
  -[SharedChannelCreateRequest hasChannelOwnershipType]
  -[SharedChannelCreateRequest channelOwnershipTypeAsString:]
  -[SharedChannelCreateRequest StringAsChannelOwnershipType:]


SKAStatusPublishingServiceClientConnection : NSObject
 @property  NSXPCConnection *xpcConnection
 @property  <SKAStatusPublishingServiceClientConnectionLifecycleDelegate> *connectionLifecycleDelegate
 @property  int processIdentifier

  // class methods
  +[SKAStatusPublishingServiceClientConnection logger]
  +[SKAStatusPublishingServiceClientConnection _connection:isEntitledForPublishingWithStatusTypeIdentifier:]
  +[SKAStatusPublishingServiceClientConnection clientIsEntitledForAtLeastOnePublishingServiceType:]

  // instance methods
  -[SKAStatusPublishingServiceClientConnection setXpcConnection:]
  -[SKAStatusPublishingServiceClientConnection xpcConnection]
  -[SKAStatusPublishingServiceClientConnection .cxx_destruct]
  -[SKAStatusPublishingServiceClientConnection processIdentifier]
  -[SKAStatusPublishingServiceClientConnection dealloc]
  -[SKAStatusPublishingServiceClientConnection connectionLifecycleDelegate]
  -[SKAStatusPublishingServiceClientConnection initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:]
  -[SKAStatusPublishingServiceClientConnection asynchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusPublishingServiceClientConnection synchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusPublishingServiceClientConnection clientIsEntitledForPublishingWithStatusTypeIdentifier:]
  -[SKAStatusPublishingServiceClientConnection setConnectionLifecycleDelegate:]


SKAStatusPublishingManager : NSObject <SKAStatusPublishingManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  <SKAAccountProviding> *accountProvider
 @property  <SKAInvitationManaging> *invitationManager
 @property  NSObject<OS_dispatch_queue> *internalWorkQueue
 @property  BOOL pendingRequestScheduled
 @property  BOOL clientIsRateLimited
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusPublishingManager logger]
  +[SKAStatusPublishingManager _noPersonalChannelErrorForStatusTypeIdentifier:]
  +[SKAStatusPublishingManager _errorForRateLimit]
  +[SKAStatusPublishingManager _errorForDuplicateStatusPublishRequestWithIdentifier:]
  +[SKAStatusPublishingManager _errorForStatusPublishRequestWithIdentifier:requestedStatusCreationDate:isOlderThanExistingStatus:existingStatusCreationDate:]

  // instance methods
  -[SKAStatusPublishingManager encryptionManager]
  -[SKAStatusPublishingManager channelManager]
  -[SKAStatusPublishingManager databaseManager]
  -[SKAStatusPublishingManager _shouldClientRateLimit]
  -[SKAStatusPublishingManager setEncryptionManager:]
  -[SKAStatusPublishingManager _shouldAllowPublishForPublishRequest:onChannel:error:]
  -[SKAStatusPublishingManager _markPublishAttempt]
  -[SKAStatusPublishingManager _rateLimitDelayTime]
  -[SKAStatusPublishingManager pendingRequestScheduled]
  -[SKAStatusPublishingManager _shouldRetryWithDelayForError:]
  -[SKAStatusPublishingManager internalWorkQueue]
  -[SKAStatusPublishingManager .cxx_destruct]
  -[SKAStatusPublishingManager setDatabaseManager:]
  -[SKAStatusPublishingManager publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:completion:]
  -[SKAStatusPublishingManager _rapidPublishesTimescale]
  -[SKAStatusPublishingManager clientIsRateLimited]
  -[SKAStatusPublishingManager invitationManager]
  -[SKAStatusPublishingManager publishPendingRequestForReason:]
  -[SKAStatusPublishingManager _maxRetryCount]
  -[SKAStatusPublishingManager accountProvider]
  -[SKAStatusPublishingManager removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:]
  -[SKAStatusPublishingManager setInternalWorkQueue:]
  -[SKAStatusPublishingManager findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAStatusPublishingManager setInvitationManager:]
  -[SKAStatusPublishingManager _shouldRollChannelForError:]
  -[SKAStatusPublishingManager setAccountProvider:]
  -[SKAStatusPublishingManager _shouldAbandonRequestForError:]
  -[SKAStatusPublishingManager _publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:retryCount:completion:]
  -[SKAStatusPublishingManager setClientIsRateLimited:]
  -[SKAStatusPublishingManager _removePendingPublishRequestWithUniqueIdentifier:databaseContext:]
  -[SKAStatusPublishingManager setChannelManager:]
  -[SKAStatusPublishingManager _removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:databaseContext:]
  -[SKAStatusPublishingManager createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAStatusPublishingManager setPendingRequestScheduled:]
  -[SKAStatusPublishingManager publishPendingRequestsWithDelay:]
  -[SKAStatusPublishingManager _shouldReauthForError:]
  -[SKAStatusPublishingManager initWithDatabaseManager:channelManager:accountProvider:encryptionManager:invitationManager:]
  -[SKAStatusPublishingManager ensurePendingPublishRequestExistsWithPublishRequest:forStatusTypeIdentifier:databaseContext:]
  -[SKAStatusPublishingManager _maxRapidPublishes]
  -[SKAStatusPublishingManager _pendingDelayTime]


SKADatabaseChannel : NSObject
 @property  MPStatusKitOutgoingRatchet *currentOutgoingRatchet
 @property  NSData *channelToken
 @property  NSString *identifier
 @property  BOOL personal
 @property  BOOL decomissioned
 @property  NSData *currentOutgoingRatchetState
 @property  NSData *dateChannelCreated
 @property  NSString *statusType
 @property  NSArray *invitedUsers

  // class methods
  +[SKADatabaseChannel logger]

  // instance methods
  -[SKADatabaseChannel statusType]
  -[SKADatabaseChannel .cxx_destruct]
  -[SKADatabaseChannel identifier]
  -[SKADatabaseChannel isPersonal]
  -[SKADatabaseChannel currentOutgoingRatchet]
  -[SKADatabaseChannel channelToken]
  -[SKADatabaseChannel initWithChannelToken:identifier:personal:decomissioned:currentOutgoingRatchetState:dateCreated:statusType:invitedUsers:]
  -[SKADatabaseChannel isDecomissioned]
  -[SKADatabaseChannel currentOutgoingRatchetState]
  -[SKADatabaseChannel dateChannelCreated]
  -[SKADatabaseChannel setDateChannelCreated:]
  -[SKADatabaseChannel invitedUsers]
  -[SKADatabaseChannel initWithCoreDataChannels:]


SKAMessagingProvider : NSObject <IDSServiceDelegate, SKAMessagingProviding>
 @property  IDSService *service
 @property  NSString *serviceIdentifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription
 @property  <SKAMessagingProvidingDelegate> *delegate

  // class methods
  +[SKAMessagingProvider logger]
  +[SKAMessagingProvider _noValidIDSDetintationError]

  // instance methods
  -[SKAMessagingProvider service:account:incomingMessage:fromID:context:]
  -[SKAMessagingProvider setServiceIdentifier:]
  -[SKAMessagingProvider serviceIdentifier]
  -[SKAMessagingProvider .cxx_destruct]
  -[SKAMessagingProvider sendMessage:toHandles:fromHandle:error:]
  -[SKAMessagingProvider setDelegate:]
  -[SKAMessagingProvider isHandleAvailableToMessageFrom:]
  -[SKAMessagingProvider sendMessage:toHandle:fromHandle:error:]
  -[SKAMessagingProvider _keysharingIsDisabledByServer]
  -[SKAMessagingProvider service]
  -[SKAMessagingProvider delegate]
  -[SKAMessagingProvider isHandleMessageable:completion:]
  -[SKAMessagingProvider service:didHintCheckingTransportLogWithReason:]
  -[SKAMessagingProvider setService:]
  -[SKAMessagingProvider resolveSenderHandleWithPreferredSenderHandle:]
  -[SKAMessagingProvider initWithDelegate:serviceIdentifier:queue:]


SKAStatusPublishingServiceClient : NSObject <SKStatusPublishingDaemonProtocol, SKAStatusPublishingServiceClientConnectionLifecycleDelegate>
 @property  SKAStatusPublishingServiceClientConnection *clientConnection
 @property  <SKAStatusPublishingServiceClientDelegate> *delegate
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKADatabaseProviding> *databaseProvider
 @property  <SKAMessagingProviding> *messagingProvider
 @property  SKAInvitationManager *invitationManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAStatusPublishingManaging> *publishingManager
 @property  BOOL accountIsStatusKitCapable
 @property  BOOL accountCheckCompleted
 @property  NSObject<OS_dispatch_queue> *queue
 @property  NSString *statusTypeIdenfifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusPublishingServiceClient logger]
  +[SKAStatusPublishingServiceClient _noPersonalChannelErrorForStatusTypeIdentifier:]
  +[SKAStatusPublishingServiceClient _missingEntitlmentErrorForStatusTypeIdentifier:]
  +[SKAStatusPublishingServiceClient _accountNotCapableError]
  +[SKAStatusPublishingServiceClient _dateCreatedDriftError]
  +[SKAStatusPublishingServiceClient _unableToResolveSenderHandleError]
  +[SKAStatusPublishingServiceClient _noUsersToShareWithError]

  // instance methods
  -[SKAStatusPublishingServiceClient databaseProvider]
  -[SKAStatusPublishingServiceClient channelManager]
  -[SKAStatusPublishingServiceClient setClientConnection:]
  -[SKAStatusPublishingServiceClient databaseManager]
  -[SKAStatusPublishingServiceClient messagingProvider]
  -[SKAStatusPublishingServiceClient setMessagingProvider:]
  -[SKAStatusPublishingServiceClient .cxx_destruct]
  -[SKAStatusPublishingServiceClient setDatabaseManager:]
  -[SKAStatusPublishingServiceClient setDelegate:]
  -[SKAStatusPublishingServiceClient setDatabaseProvider:]
  -[SKAStatusPublishingServiceClient invitationManager]
  -[SKAStatusPublishingServiceClient setQueue:]
  -[SKAStatusPublishingServiceClient setPublishingManager:]
  -[SKAStatusPublishingServiceClient clientConnection]
  -[SKAStatusPublishingServiceClient setInvitationManager:]
  -[SKAStatusPublishingServiceClient delegate]
  -[SKAStatusPublishingServiceClient queue]
  -[SKAStatusPublishingServiceClient setChannelManager:]
  -[SKAStatusPublishingServiceClient fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient publishingManager]
  -[SKAStatusPublishingServiceClient publishStatusRequest:statusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient invitedHandlesForStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient removeInvitedHandles:statusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient registerForDelegateCallbacksWithStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient publishingServiceClientConnectionWasInterrupted:]
  -[SKAStatusPublishingServiceClient publishingServiceClientConnectionWasInvalidated:]
  -[SKAStatusPublishingServiceClient _delayForStatusPublishRequest:]
  -[SKAStatusPublishingServiceClient accountIsStatusKitCapableWithCompletion:]
  -[SKAStatusPublishingServiceClient setAccountIsStatusKitCapable:]
  -[SKAStatusPublishingServiceClient setAccountCheckCompleted:]
  -[SKAStatusPublishingServiceClient accountIsStatusKitCapable]
  -[SKAStatusPublishingServiceClient _serverBagNumberForKey:]
  -[SKAStatusPublishingServiceClient _serverBagTimeIntervalForKey:withDefaultValue:]
  -[SKAStatusPublishingServiceClient _scheduledPublishMaxDelayTime]
  -[SKAStatusPublishingServiceClient _unscheduledPublishMaxDelayTime]
  -[SKAStatusPublishingServiceClient _secondaryDeviceRepublishMaxDelayTime]
  -[SKAStatusPublishingServiceClient _secondaryDeviceRepublishMinDelayTime]
  -[SKAStatusPublishingServiceClient _randomSecondaryDeviceRepublishDelay]
  -[SKAStatusPublishingServiceClient _randomScheduledPublishDelay]
  -[SKAStatusPublishingServiceClient _randomUnscheduledPublishDelay]
  -[SKAStatusPublishingServiceClient initWithXPCConnection:queue:delegate:databaseManager:invitationManager:publishingManager:channelManager:]
  -[SKAStatusPublishingServiceClient statusTypeIdenfifier]
  -[SKAStatusPublishingServiceClient accountCheckCompleted]


SKAStatusSubscriptionServiceClient : NSObject <SKStatusSubscriptionDaemonProtocol, SKAClientConnectionRepresentable, SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>
 @property  SKAStatusSubscriptionServiceClientConnection *clientConnection
 @property  <SKAStatusSubscriptionServiceClientDelegate> *delegate
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAStatusSubscriptionManaging> *subscriptionManager
 @property  BOOL accountCheckCompleted
 @property  BOOL accountIsStatusKitCapable
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  NSObject<OS_dispatch_queue> *queue
 @property  NSString *statusTypeIdenfifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusSubscriptionServiceClient logger]
  +[SKAStatusSubscriptionServiceClient _missingEntitlmentErrorForStatusTypeIdentifier:]
  +[SKAStatusSubscriptionServiceClient _accountNotCapableError]
  +[SKAStatusSubscriptionServiceClient _subscriptionIdentifierNotFoundError:]
  +[SKAStatusSubscriptionServiceClient _genericMissingSubscriptionEntitlmentError]

  // instance methods
  -[SKAStatusSubscriptionServiceClient subscriptionManager]
  -[SKAStatusSubscriptionServiceClient encryptionManager]
  -[SKAStatusSubscriptionServiceClient setClientConnection:]
  -[SKAStatusSubscriptionServiceClient databaseManager]
  -[SKAStatusSubscriptionServiceClient setEncryptionManager:]
  -[SKAStatusSubscriptionServiceClient .cxx_destruct]
  -[SKAStatusSubscriptionServiceClient setDatabaseManager:]
  -[SKAStatusSubscriptionServiceClient setDelegate:]
  -[SKAStatusSubscriptionServiceClient releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient setQueue:]
  -[SKAStatusSubscriptionServiceClient clientConnection]
  -[SKAStatusSubscriptionServiceClient setSubscriptionManager:]
  -[SKAStatusSubscriptionServiceClient retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient delegate]
  -[SKAStatusSubscriptionServiceClient queue]
  -[SKAStatusSubscriptionServiceClient registerForDelegateCallbacksWithStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient subscriptionMetadataForHandle:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:]
  -[SKAStatusSubscriptionServiceClient allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient accountIsStatusKitCapableWithCompletion:]
  -[SKAStatusSubscriptionServiceClient setAccountIsStatusKitCapable:]
  -[SKAStatusSubscriptionServiceClient setAccountCheckCompleted:]
  -[SKAStatusSubscriptionServiceClient accountIsStatusKitCapable]
  -[SKAStatusSubscriptionServiceClient statusTypeIdenfifier]
  -[SKAStatusSubscriptionServiceClient accountCheckCompleted]
  -[SKAStatusSubscriptionServiceClient channelMatchesClientStatusTypeIdentifier:]
  -[SKAStatusSubscriptionServiceClient _subscriptionMetadataForChannel:]
  -[SKAStatusSubscriptionServiceClient _currentStatusForChannel:]
  -[SKAStatusSubscriptionServiceClient _handlesAssociatedWithChannel:]
  -[SKAStatusSubscriptionServiceClient _validateChannelIsKnownForSubscriptionIdentifier:statusTypeIdentifier:databaseContext:]
  -[SKAStatusSubscriptionServiceClient validatePersonalChannel:matchesSubscriptionValidationToken:fromSender:]
  -[SKAStatusSubscriptionServiceClient validatePersonalChannel:matchesEncryptionValidationToken:fromSender:]
  -[SKAStatusSubscriptionServiceClient subscriptionServiceClientConnectionWasInvalidated:]
  -[SKAStatusSubscriptionServiceClient subscriptionServiceClientConnectionWasInterrupted:]
  -[SKAStatusSubscriptionServiceClient initWithXPCConnection:queue:delegate:databaseManager:subscriptionManager:encryptionManager:]
  -[SKAStatusSubscriptionServiceClient handleRemoteDatabaseChangeForChannels:]
  -[SKAStatusSubscriptionServiceClient handleReceivedStatusUpdate:onChannel:]
  -[SKAStatusSubscriptionServiceClient handleReceivedInvitationForChannel:]


SKAStatusReceivingManager : NSObject <SKAStatusReceivingManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  <SKAStatusReceivingManagingDelegate> *delegate
 @property  NSObject<OS_dispatch_queue> *backgroundCleanupQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusReceivingManager logger]

  // instance methods
  -[SKAStatusReceivingManager encryptionManager]
  -[SKAStatusReceivingManager databaseManager]
  -[SKAStatusReceivingManager setEncryptionManager:]
  -[SKAStatusReceivingManager .cxx_destruct]
  -[SKAStatusReceivingManager setDatabaseManager:]
  -[SKAStatusReceivingManager setDelegate:]
  -[SKAStatusReceivingManager backgroundCleanupQueue]
  -[SKAStatusReceivingManager handleIncomingStatusData:onChannelIdentifier:dateReceived:dateExpired:serverTime:]
  -[SKAStatusReceivingManager setBackgroundCleanupQueue:]
  -[SKAStatusReceivingManager delegate]
  -[SKAStatusReceivingManager initWithDatabaseManager:encryptionManager:delegate:]


SKAChannelManager : NSObject <SKAPushManagingDelegate, SKAChannelManaging>
 @property  <SKAPushManaging> *pushManager
 @property  <SKAAccountProviding> *accountProvider
 @property  <SKAChannelManagingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAChannelManager logger]
  +[SKAChannelManager _jwtTokenNotFoundError]

  // instance methods
  -[SKAChannelManager activeChannelSubscriptionsWithCompletion:]
  -[SKAChannelManager .cxx_destruct]
  -[SKAChannelManager subscribeToChannels:]
  -[SKAChannelManager serverTime]
  -[SKAChannelManager _createPayloadDataFromData:]
  -[SKAChannelManager pushManager:didReceiveData:onChannel:dateReceived:dateExpired:]
  -[SKAChannelManager setDelegate:]
  -[SKAChannelManager unsubscribeFromChannels:]
  -[SKAChannelManager pushManager]
  -[SKAChannelManager accountProvider]
  -[SKAChannelManager setPushManager:]
  -[SKAChannelManager initWithPushManager:accountProvider:delegate:]
  -[SKAChannelManager _getJWTToken]
  -[SKAChannelManager setAccountProvider:]
  -[SKAChannelManager delegate]
  -[SKAChannelManager createChannelWithCompletion:]
  -[SKAChannelManager publishData:onChannel:withChannelToken:publishInitiateTime:isPendingPublish:isScheduledPublish:retryCount:completion:]
  -[SKAChannelManager pushManager:failedToSubscribeToChannel:withError:]


SharedChannelPublishResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasRetryIntervalSeconds
 @property  unsigned int retryIntervalSeconds

  // instance methods
  -[SharedChannelPublishResponse setHasStatus:]
  -[SharedChannelPublishResponse statusAsString:]
  -[SharedChannelPublishResponse mergeFrom:]
  -[SharedChannelPublishResponse StringAsStatus:]
  -[SharedChannelPublishResponse hasStatus]
  -[SharedChannelPublishResponse dictionaryRepresentation]
  -[SharedChannelPublishResponse writeTo:]
  -[SharedChannelPublishResponse isEqual:]
  -[SharedChannelPublishResponse copyTo:]
  -[SharedChannelPublishResponse readFrom:]
  -[SharedChannelPublishResponse status]
  -[SharedChannelPublishResponse setStatus:]
  -[SharedChannelPublishResponse copyWithZone:]
  -[SharedChannelPublishResponse setRetryIntervalSeconds:]
  -[SharedChannelPublishResponse retryIntervalSeconds]
  -[SharedChannelPublishResponse hasRetryIntervalSeconds]
  -[SharedChannelPublishResponse setHasRetryIntervalSeconds:]


SKADatabaseReceivedInvitation : NSObject
 @property  SKHandle *invitedSKHandle
 @property  SKHandle *senderSKHandle
 @property  MPStatusKitIncomingRatchet *incomingRatchet
 @property  SKInvitationPayload *skInvitationPayload
 @property  NSString *senderHandle
 @property  NSString *invitedHandle
 @property  NSString *statusTypeIdentifier
 @property  NSString *invitationIdentifier
 @property  NSDate *dateInvitationCreated
 @property  NSData *incomingRatchetState
 @property  NSData *invitationPayload

  // class methods
  +[SKADatabaseReceivedInvitation logger]

  // instance methods
  -[SKADatabaseReceivedInvitation .cxx_destruct]
  -[SKADatabaseReceivedInvitation statusTypeIdentifier]
  -[SKADatabaseReceivedInvitation invitationIdentifier]
  -[SKADatabaseReceivedInvitation senderHandle]
  -[SKADatabaseReceivedInvitation invitationPayload]
  -[SKADatabaseReceivedInvitation incomingRatchet]
  -[SKADatabaseReceivedInvitation invitedSKHandle]
  -[SKADatabaseReceivedInvitation senderSKHandle]
  -[SKADatabaseReceivedInvitation skInvitationPayload]
  -[SKADatabaseReceivedInvitation invitedHandle]
  -[SKADatabaseReceivedInvitation dateInvitationCreated]
  -[SKADatabaseReceivedInvitation incomingRatchetState]
  -[SKADatabaseReceivedInvitation initWithInvitationIdentifier:senderHandle:invitedHandle:statusTypeIdentifier:dateInvitationCreated:incomingRatchetState:invitationPayload:]
  -[SKADatabaseReceivedInvitation initWithCoreDataReceivedInvitation:]


SKADatabaseTransientSubscriptionHistory : NSObject
 @property  NSString *channelIdentifier
 @property  NSDate *lastSubscriptionDate

  // instance methods
  -[SKADatabaseTransientSubscriptionHistory .cxx_destruct]
  -[SKADatabaseTransientSubscriptionHistory channelIdentifier]
  -[SKADatabaseTransientSubscriptionHistory lastSubscriptionDate]
  -[SKADatabaseTransientSubscriptionHistory initWithChannelIdentifier:lastSubscriptionDate:]
  -[SKADatabaseTransientSubscriptionHistory initWithCoreDataTransientSubscriptionHistory:]


SKAAccountProvider : NSObject <SKAAccountProviding>
 @property  NSObject<OS_dispatch_queue> *tokenFetchQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAAccountProvider logger]

  // instance methods
  -[SKAAccountProvider .cxx_destruct]
  -[SKAAccountProvider _primarySystemiCloudAccountWithError:]
  -[SKAAccountProvider init]
  -[SKAAccountProvider refreshCredentialForPrimaryAccountWithCompletion:]
  -[SKAAccountProvider jwtTokenForPrimaryAccountWithError:]
  -[SKAAccountProvider _markReauthAttempt]
  -[SKAAccountProvider _shouldAttemptReauth]
  -[SKAAccountProvider setTokenFetchQueue:]
  -[SKAAccountProvider _authResetTime]
  -[SKAAccountProvider _maxReauthCount]
  -[SKAAccountProvider tokenFetchQueue]


ChannelIdentity : PBCodable <NSCopying>
 @property  BOOL hasChannelTopic
 @property  NSString *channelTopic
 @property  BOOL hasChannelId
 @property  NSData *channelId
 @property  BOOL hasChannelToken
 @property  NSData *channelToken
 @property  BOOL hasChannelOwnershipType
 @property  int channelOwnershipType

  // instance methods
  -[ChannelIdentity mergeFrom:]
  -[ChannelIdentity setChannelId:]
  -[ChannelIdentity .cxx_destruct]
  -[ChannelIdentity dictionaryRepresentation]
  -[ChannelIdentity writeTo:]
  -[ChannelIdentity isEqual:]
  -[ChannelIdentity copyTo:]
  -[ChannelIdentity readFrom:]
  -[ChannelIdentity channelId]
  -[ChannelIdentity setChannelTopic:]
  -[ChannelIdentity copyWithZone:]
  -[ChannelIdentity channelTopic]
  -[ChannelIdentity hasChannelId]
  -[ChannelIdentity hasChannelTopic]
  -[ChannelIdentity channelOwnershipType]
  -[ChannelIdentity setChannelOwnershipType:]
  -[ChannelIdentity setHasChannelOwnershipType:]
  -[ChannelIdentity hasChannelOwnershipType]
  -[ChannelIdentity channelOwnershipTypeAsString:]
  -[ChannelIdentity StringAsChannelOwnershipType:]
  -[ChannelIdentity channelToken]
  -[ChannelIdentity setChannelToken:]
  -[ChannelIdentity hasChannelToken]


SKAPushManager : NSObject <APSConnectionDelegate, SKASystemMonitorListener, SKAPushManaging>
 @property  NSObject<OS_dispatch_queue> *queue
 @property  SKASystemMonitor *systemMonitor
 @property  APSConnection *connection
 @property  FTMessageDelivery *messageDelivery
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription
 @property  <SKAPushManagingDelegate> *delegate

  // class methods
  +[SKAPushManager logger]

  // instance methods
  -[SKAPushManager connection:channelSubscriptionsFailedWithFailures:]
  -[SKAPushManager setSystemMonitor:]
  -[SKAPushManager messageDelivery]
  -[SKAPushManager systemMonitor]
  -[SKAPushManager connection:didReceivePublicToken:]
  -[SKAPushManager systemDidLeaveFirstDataProtectionLock]
  -[SKAPushManager switchFilterToNonwaking]
  -[SKAPushManager connection:didReceiveIncomingMessage:]
  -[SKAPushManager .cxx_destruct]
  -[SKAPushManager subscribeToChannels:]
  -[SKAPushManager serverTime]
  -[SKAPushManager setConnection:]
  -[SKAPushManager setDelegate:]
  -[SKAPushManager _initializeAPSConnection]
  -[SKAPushManager _sharedChannelsIsDisabledByServer]
  -[SKAPushManager unsubscribeFromChannels:]
  -[SKAPushManager switchFilterToEnabled]
  -[SKAPushManager _pushEnvironment]
  -[SKAPushManager setQueue:]
  -[SKAPushManager connection]
  -[SKAPushManager subscribedChannelsWithCompletion:]
  -[SKAPushManager createChannelWithProtoData:completion:]
  -[SKAPushManager publishStatus:completion:]
  -[SKAPushManager delegate]
  -[SKAPushManager initWithQueue:systemMonitor:]
  -[SKAPushManager queue]
  -[SKAPushManager setMessageDelivery:]


SKADatabaseStatus : NSObject
 @property  NSString *channelIdentifier
 @property  NSDate *dateCreated
 @property  NSDate *datePublished
 @property  NSDate *dateReceived
 @property  NSDate *dateExpired
 @property  NSData *rawData
 @property  NSString *uniqueIdentifier
 @property  BOOL isExpired

  // class methods
  +[SKADatabaseStatus logger]

  // instance methods
  -[SKADatabaseStatus uniqueIdentifier]
  -[SKADatabaseStatus .cxx_destruct]
  -[SKADatabaseStatus isExpired]
  -[SKADatabaseStatus dateCreated]
  -[SKADatabaseStatus channelIdentifier]
  -[SKADatabaseStatus rawData]
  -[SKADatabaseStatus dateReceived]
  -[SKADatabaseStatus datePublished]
  -[SKADatabaseStatus dateExpired]
  -[SKADatabaseStatus initWithChannelIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:uniqueIdentifier:]
  -[SKADatabaseStatus initWithCoreDataStatus:]


SharedChannelCreateResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasRetryIntervalSeconds
 @property  unsigned int retryIntervalSeconds

  // instance methods
  -[SharedChannelCreateResponse setHasStatus:]
  -[SharedChannelCreateResponse statusAsString:]
  -[SharedChannelCreateResponse mergeFrom:]
  -[SharedChannelCreateResponse StringAsStatus:]
  -[SharedChannelCreateResponse hasStatus]
  -[SharedChannelCreateResponse .cxx_destruct]
  -[SharedChannelCreateResponse dictionaryRepresentation]
  -[SharedChannelCreateResponse writeTo:]
  -[SharedChannelCreateResponse isEqual:]
  -[SharedChannelCreateResponse copyTo:]
  -[SharedChannelCreateResponse readFrom:]
  -[SharedChannelCreateResponse status]
  -[SharedChannelCreateResponse setStatus:]
  -[SharedChannelCreateResponse copyWithZone:]
  -[SharedChannelCreateResponse setRetryIntervalSeconds:]
  -[SharedChannelCreateResponse retryIntervalSeconds]
  -[SharedChannelCreateResponse hasRetryIntervalSeconds]
  -[SharedChannelCreateResponse channelIdentity]
  -[SharedChannelCreateResponse setChannelIdentity:]
  -[SharedChannelCreateResponse setHasRetryIntervalSeconds:]
  -[SharedChannelCreateResponse hasChannelIdentity]


SKAStatusSubscriptionManager : NSObject <SKAStatusSubscriptionManaging>
 @property  NSMapTable *activeTransientSubscriptionsByClient
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAPushManaging> *pushManager
 @property  NSObject<OS_dispatch_queue> *internalWorkQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusSubscriptionManager logger]

  // instance methods
  -[SKAStatusSubscriptionManager channelManager]
  -[SKAStatusSubscriptionManager databaseManager]
  -[SKAStatusSubscriptionManager updateRegisteredSubscriptionsForActiveAssertionsWithCompletion:]
  -[SKAStatusSubscriptionManager releaseAllTransientSubscriptionAssertionsAssociatedWithClient:completion:]
  -[SKAStatusSubscriptionManager activeTransientSubscriptionsByClient]
  -[SKAStatusSubscriptionManager _hardMaxSubscriptionCount]
  -[SKAStatusSubscriptionManager internalWorkQueue]
  -[SKAStatusSubscriptionManager initWithDatabaseManager:channelManager:pushManager:]
  -[SKAStatusSubscriptionManager .cxx_destruct]
  -[SKAStatusSubscriptionManager _removeTransientSubscriptionAssertionForClient:subscriptionIdentifier:]
  -[SKAStatusSubscriptionManager setDatabaseManager:]
  -[SKAStatusSubscriptionManager allSubscriptionIdentifiersWithActiveSubscriptionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionManager _subscriptionTTL]
  -[SKAStatusSubscriptionManager releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionManager pushManager]
  -[SKAStatusSubscriptionManager _addTransientSubscriptionAssertionForClient:subscriptionIdentifier:]
  -[SKAStatusSubscriptionManager _activeTransientSubscriptionsForClient:]
  -[SKAStatusSubscriptionManager _statusTypeIdentifiersRequiringSelfSubscription]
  -[SKAStatusSubscriptionManager setPushManager:]
  -[SKAStatusSubscriptionManager _markCacheSubscriptionDateForChannelIdentifier:]
  -[SKAStatusSubscriptionManager retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:]
  -[SKAStatusSubscriptionManager _enforceSubscriptionsHardCapOnSubscriptionIdentifiers:]
  -[SKAStatusSubscriptionManager setInternalWorkQueue:]
  -[SKAStatusSubscriptionManager allSubscriptionIdentifiersWithActiveAssertionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionManager _fetchAllClientActiveSubscriptionAssertions]
  -[SKAStatusSubscriptionManager retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionManager releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:]
  -[SKAStatusSubscriptionManager setChannelManager:]
  -[SKAStatusSubscriptionManager setActiveTransientSubscriptionsByClient:]
  -[SKAStatusSubscriptionManager _recentlyReleasedTransientSubscriptionAssertionIdentifiersExcludingSubscriptionIdentifiers:count:databaseContext:]
  -[SKAStatusSubscriptionManager _fetchAllActiveSubscriptionAssertionsWithCache]
  -[SKAStatusSubscriptionManager _allPersonalChannelIdentifiersRequiringSelfSubscriptionWithDatabaseContext:]
  -[SKAStatusSubscriptionManager _maxSubscriptionCacheCount]
  -[SKAStatusSubscriptionManager _activeTransientAssertionsExist]
  -[SKAStatusSubscriptionManager _sortAndDedupeSubscriptionIdentifiers:]


SKATransientSubscriptionAssertion : NSObject
 @property  NSObject<OS_os_activity> *osActivity
 @property  NSString *subscriptionIdentifier

  // class methods
  +[SKATransientSubscriptionAssertion logger]

  // instance methods
  -[SKATransientSubscriptionAssertion subscriptionIdentifier]
  -[SKATransientSubscriptionAssertion .cxx_destruct]
  -[SKATransientSubscriptionAssertion osActivity]
  -[SKATransientSubscriptionAssertion isEqual:]
  -[SKATransientSubscriptionAssertion dealloc]
  -[SKATransientSubscriptionAssertion initWithSubscriptionIdentifier:]
  -[SKATransientSubscriptionAssertion isEqualToTransientSubscription:]


AuthCredential : PBCodable <NSCopying>
 @property  BOOL hasSimpleJwt
 @property  NSString *simpleJwt
 @property  BOOL hasAuthCredentialOneof
 @property  int authCredentialOneof

  // instance methods
  -[AuthCredential mergeFrom:]
  -[AuthCredential .cxx_destruct]
  -[AuthCredential dictionaryRepresentation]
  -[AuthCredential writeTo:]
  -[AuthCredential isEqual:]
  -[AuthCredential copyTo:]
  -[AuthCredential readFrom:]
  -[AuthCredential copyWithZone:]
  -[AuthCredential setSimpleJwt:]
  -[AuthCredential clearOneofValuesForAuthCredentialOneof]
  -[AuthCredential hasSimpleJwt]
  -[AuthCredential authCredentialOneof]
  -[AuthCredential setAuthCredentialOneof:]
  -[AuthCredential setHasAuthCredentialOneof:]
  -[AuthCredential hasAuthCredentialOneof]
  -[AuthCredential authCredentialOneofAsString:]
  -[AuthCredential StringAsAuthCredentialOneof:]
  -[AuthCredential simpleJwt]


SharedChannelPublishRequest : PBRequest <NSCopying>
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelPublishPayload
 @property  ChannelPublishPayload *channelPublishPayload

  // instance methods
  -[SharedChannelPublishRequest mergeFrom:]
  -[SharedChannelPublishRequest .cxx_destruct]
  -[SharedChannelPublishRequest dictionaryRepresentation]
  -[SharedChannelPublishRequest writeTo:]
  -[SharedChannelPublishRequest isEqual:]
  -[SharedChannelPublishRequest copyTo:]
  -[SharedChannelPublishRequest readFrom:]
  -[SharedChannelPublishRequest copyWithZone:]
  -[SharedChannelPublishRequest authCredential]
  -[SharedChannelPublishRequest setAuthCredential:]
  -[SharedChannelPublishRequest hasAuthCredential]
  -[SharedChannelPublishRequest setChannelPublishPayload:]
  -[SharedChannelPublishRequest hasChannelPublishPayload]
  -[SharedChannelPublishRequest channelPublishPayload]


ChannelPublishPayload : PBCodable <NSCopying>
 @property  BOOL hasPublishInitiateTimestampMillis
 @property  unsigned long publishInitiateTimestampMillis
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasPublishPayload
 @property  NSData *publishPayload
 @property  BOOL hasPublishPayloadExpiryTtlMillis
 @property  unsigned long publishPayloadExpiryTtlMillis
 @property  BOOL hasPushPriority
 @property  int pushPriority
 @property  BOOL hasPendingPublishHint
 @property  BOOL pendingPublishHint
 @property  BOOL hasScheduledPublishHint
 @property  BOOL scheduledPublishHint
 @property  BOOL hasRetryCount
 @property  unsigned int retryCount

  // instance methods
  -[ChannelPublishPayload mergeFrom:]
  -[ChannelPublishPayload .cxx_destruct]
  -[ChannelPublishPayload dictionaryRepresentation]
  -[ChannelPublishPayload writeTo:]
  -[ChannelPublishPayload isEqual:]
  -[ChannelPublishPayload copyTo:]
  -[ChannelPublishPayload readFrom:]
  -[ChannelPublishPayload setPushPriority:]
  -[ChannelPublishPayload setRetryCount:]
  -[ChannelPublishPayload retryCount]
  -[ChannelPublishPayload copyWithZone:]
  -[ChannelPublishPayload pushPriority]
  -[ChannelPublishPayload hasRetryCount]
  -[ChannelPublishPayload setHasRetryCount:]
  -[ChannelPublishPayload channelIdentity]
  -[ChannelPublishPayload setPublishInitiateTimestampMillis:]
  -[ChannelPublishPayload setPendingPublishHint:]
  -[ChannelPublishPayload setScheduledPublishHint:]
  -[ChannelPublishPayload setChannelIdentity:]
  -[ChannelPublishPayload setPublishPayloadExpiryTtlMillis:]
  -[ChannelPublishPayload setPublishPayload:]
  -[ChannelPublishPayload hasChannelIdentity]
  -[ChannelPublishPayload setHasPublishInitiateTimestampMillis:]
  -[ChannelPublishPayload hasPublishInitiateTimestampMillis]
  -[ChannelPublishPayload hasPublishPayload]
  -[ChannelPublishPayload setHasPublishPayloadExpiryTtlMillis:]
  -[ChannelPublishPayload hasPublishPayloadExpiryTtlMillis]
  -[ChannelPublishPayload setHasPushPriority:]
  -[ChannelPublishPayload hasPushPriority]
  -[ChannelPublishPayload pushPriorityAsString:]
  -[ChannelPublishPayload StringAsPushPriority:]
  -[ChannelPublishPayload setHasPendingPublishHint:]
  -[ChannelPublishPayload hasPendingPublishHint]
  -[ChannelPublishPayload setHasScheduledPublishHint:]
  -[ChannelPublishPayload hasScheduledPublishHint]
  -[ChannelPublishPayload publishInitiateTimestampMillis]
  -[ChannelPublishPayload publishPayload]
  -[ChannelPublishPayload publishPayloadExpiryTtlMillis]
  -[ChannelPublishPayload pendingPublishHint]
  -[ChannelPublishPayload scheduledPublishHint]


SKAStatusServer : NSObject <NSXPCListenerDelegate, SKADatabaseProvidingDelegate, SKAMessagingProvidingDelegate, SKAChannelManagingDelegate, SKAStatusReceivingManagingDelegate, SKADatabaseManagingDelegate, SKAInvitationManagingDelegate, SKAStatusPublishingServiceClientDelegate, SKAStatusSubscriptionServiceClientDelegate>
 @property  NSXPCListener *publishingServiceListener
 @property  NSObject<OS_dispatch_queue> *publishingServiceConnectionQueue
 @property  NSMutableArray *publishingServiceConnectedClients
 @property  NSXPCListener *subscriptionServiceListener
 @property  NSObject<OS_dispatch_queue> *subscriptionServiceConnectionQueue
 @property  NSMutableArray *subscriptionServiceConnectedClients
 @property  <SKADatabaseProviding> *databaseProvider
 @property  <SKADatabaseManaging> *databaseManager
 @property  NSObject<OS_dispatch_queue> *invitationManagerMessagingQueue
 @property  <SKAMessagingProviding> *invitationMessagingProvider
 @property  <SKAInvitationManaging> *invitationManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAStatusPublishingManaging> *publishingManager
 @property  <SKAStatusSubscriptionManaging> *subscriptionManager
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  <SKAStatusReceivingManaging> *statusReceivingManager
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusServer logger]
  +[SKAStatusServer sharedInstance]

  // instance methods
  -[SKAStatusServer databaseProvider]
  -[SKAStatusServer subscriptionManager]
  -[SKAStatusServer encryptionManager]
  -[SKAStatusServer channelManager]
  -[SKAStatusServer databaseManager]
  -[SKAStatusServer setPublishingServiceConnectedClients:]
  -[SKAStatusServer setEncryptionManager:]
  -[SKAStatusServer subscriptionServiceConnectionQueue]
  -[SKAStatusServer _kettleFeatureEnabled]
  -[SKAStatusServer invitationManager:didRevokeInvitationOnChannel:]
  -[SKAStatusServer shutdown]
  -[SKAStatusServer .cxx_destruct]
  -[SKAStatusServer setDatabaseManager:]
  -[SKAStatusServer invitationMessagingProvider]
  -[SKAStatusServer _shouldDonateToBiomeForStatusTypeIdentifier:]
  -[SKAStatusServer publishingServiceConnectedClients]
  -[SKAStatusServer logState]
  -[SKAStatusServer _setupMaintenanceActivity]
  -[SKAStatusServer setInvitationManagerMessagingQueue:]
  -[SKAStatusServer setDatabaseProvider:]
  -[SKAStatusServer init]
  -[SKAStatusServer invitationManager]
  -[SKAStatusServer setStatusReceivingManager:]
  -[SKAStatusServer setPublishingManager:]
  -[SKAStatusServer setPublishingServiceConnectionQueue:]
  -[SKAStatusServer statusReceivingManager:didReceiveStatusUpdate:onChannel:]
  -[SKAStatusServer statusReceivingManager]
  -[SKAStatusServer setInvitationMessagingProvider:]
  -[SKAStatusServer donateReceivedStatusToBiomeOnChannel:]
  -[SKAStatusServer publishingServiceConnectionQueue]
  -[SKAStatusServer invitationManagerMessagingQueue]
  -[SKAStatusServer databaseDidReceiveRemoteChangesForChannels:]
  -[SKAStatusServer _senderHandlesForChannel:]
  -[SKAStatusServer setSubscriptionManager:]
  -[SKAStatusServer subscriptionServiceClientWasInvalidated:]
  -[SKAStatusServer _subscriptionServiceListener:shouldAcceptNewConnection:]
  -[SKAStatusServer publishingServiceClientWasInvalidated:]
  -[SKAStatusServer setInvitationManager:]
  -[SKAStatusServer setPublishingServiceListener:]
  -[SKAStatusServer setSubscriptionServiceListener:]
  -[SKAStatusServer channelManager:failedToSubscribeToChannel:withError:]
  -[SKAStatusServer setChannelManager:]
  -[SKAStatusServer networkBecameReachable]
  -[SKAStatusServer _publishingServiceListener:shouldAcceptNewConnection:]
  -[SKAStatusServer listener:shouldAcceptNewConnection:]
  -[SKAStatusServer setSubscriptionServiceConnectionQueue:]
  -[SKAStatusServer channelManager:didReceiveData:onChannel:dateReceived:dateExpired:]
  -[SKAStatusServer subscriptionServiceConnectedClients]
  -[SKAStatusServer subscriptionServiceListener]
  -[SKAStatusServer service:didReceiveIncomingMessage:fromID:toID:messageGuid:]
  -[SKAStatusServer databaseManager:didCreateChannel:]
  -[SKAStatusServer setSubscriptionServiceConnectedClients:]
  -[SKAStatusServer publishingServiceListener]
  -[SKAStatusServer invitationManager:didReceiveInvitation:forChannel:]
  -[SKAStatusServer publishingManager]


SKADatabaseRemovedUser : NSObject
 @property  NSString *handle
 @property  NSString *statusTypeIdentifier
 @property  NSDate *dateRemoved

  // instance methods
  -[SKADatabaseRemovedUser .cxx_destruct]
  -[SKADatabaseRemovedUser dateRemoved]
  -[SKADatabaseRemovedUser statusTypeIdentifier]
  -[SKADatabaseRemovedUser handle]
  -[SKADatabaseRemovedUser initWithHandle:statusTypeIdentifier:dateRemoved:]
  -[SKADatabaseRemovedUser initWithCoreDataRemovedUser:]


SKADatabaseProvider : NSObject <SKADatabaseProviding>
 @property  NSObject<OS_dispatch_queue> *historyProcessingQueue
 @property  NSPersistentContainer *persistentContainer
 @property  CKContainer *ckContainer
 @property  <SKADatabaseProvidingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKADatabaseProvider logger]

  // instance methods
  -[SKADatabaseProvider setLastProcessedPersistentHistoryToken:]
  -[SKADatabaseProvider persistentContainer]
  -[SKADatabaseProvider fileManager]
  -[SKADatabaseProvider .cxx_destruct]
  -[SKADatabaseProvider createCkContainer]
  -[SKADatabaseProvider overrideDeviceEncryptionCheck]
  -[SKADatabaseProvider setDelegate:]
  -[SKADatabaseProvider existingManagedObjectWithID:managedObjectContext:]
  -[SKADatabaseProvider localDatabaseFileURL]
  -[SKADatabaseProvider processPersistentStoreRemoteChanges]
  -[SKADatabaseProvider historyProcessingQueue]
  -[SKADatabaseProvider deviceToDeviceEncryptedDatabaseCapableWithCompletion:]
  -[SKADatabaseProvider cloudPersistentStoreDescription]
  -[SKADatabaseProvider ckContainerIdentifier]
  -[SKADatabaseProvider setHistoryProcessingQueue:]
  -[SKADatabaseProvider databaseHasBeenCreated]
  -[SKADatabaseProvider databaseDirectoryURL]
  -[SKADatabaseProvider containerName]
  -[SKADatabaseProvider extractModifiedChannelFromPersistentStoreRemoteChangeForChannel:managedObjectContext:]
  -[SKADatabaseProvider initWithDelegate:]
  -[SKADatabaseProvider localPersistentStoreDescription]
  -[SKADatabaseProvider delegate]
  -[SKADatabaseProvider handlePersistentStoreRemoteChangeNotification:]
  -[SKADatabaseProvider extractModifiedChannelFromPersistentStoreRemoteChangeForReceivedInvitation:managedObjectContext:]
  -[SKADatabaseProvider lastProcessedPersistentHistoryTokenFileURL]
  -[SKADatabaseProvider ckContainer]
  -[SKADatabaseProvider appTransactionAuthorName]
  -[SKADatabaseProvider createPersistentContainer]
  -[SKADatabaseProvider setPersistentContainer:]
  -[SKADatabaseProvider setCkContainer:]
  -[SKADatabaseProvider newBackgroundContext]
  -[SKADatabaseProvider lastProcessedPersistentHistoryToken]
  -[SKADatabaseProvider cloudDatabaseFileURL]


SKAGeneratedEncryptionKey : NSObject
 @property  MPStatusKitOutgoingRatchet *outgoingRatchet
 @property  MPStatusKitIncomingRatchet *incomingRatchet
 @property  NSData *originalOutgoingRatchetState
 @property  NSDate *dateGenerated

  // class methods
  +[SKAGeneratedEncryptionKey logger]

  // instance methods
  -[SKAGeneratedEncryptionKey dateGenerated]
  -[SKAGeneratedEncryptionKey .cxx_destruct]
  -[SKAGeneratedEncryptionKey incomingRatchet]
  -[SKAGeneratedEncryptionKey originalOutgoingRatchetState]
  -[SKAGeneratedEncryptionKey initWithOriginalOutgoingRatchetState:dateGenerated:]
  -[SKAGeneratedEncryptionKey initWithCoreDataGeneratedEncryptionKey:]
  -[SKAGeneratedEncryptionKey outgoingRatchet]


SKAStatusSubscriptionServiceClientConnection : NSObject
 @property  NSXPCConnection *xpcConnection
 @property  <SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate> *connectionLifecycleDelegate
 @property  int processIdentifier

  // class methods
  +[SKAStatusSubscriptionServiceClientConnection logger]
  +[SKAStatusSubscriptionServiceClientConnection clientIsEntitledForAtLeastOneSubscriptionServiceType:]
  +[SKAStatusSubscriptionServiceClientConnection _connection:isEntitledForSubscriptionWithStatusTypeIdentifier:]

  // instance methods
  -[SKAStatusSubscriptionServiceClientConnection setXpcConnection:]
  -[SKAStatusSubscriptionServiceClientConnection xpcConnection]
  -[SKAStatusSubscriptionServiceClientConnection .cxx_destruct]
  -[SKAStatusSubscriptionServiceClientConnection processIdentifier]
  -[SKAStatusSubscriptionServiceClientConnection dealloc]
  -[SKAStatusSubscriptionServiceClientConnection connectionLifecycleDelegate]
  -[SKAStatusSubscriptionServiceClientConnection initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:]
  -[SKAStatusSubscriptionServiceClientConnection asynchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusSubscriptionServiceClientConnection synchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusSubscriptionServiceClientConnection setConnectionLifecycleDelegate:]
  -[SKAStatusSubscriptionServiceClientConnection clientIsEntitledForSubscriptionWithStatusTypeIdentifier:]
  -[SKAStatusSubscriptionServiceClientConnection clientIsEntitledForAtLeastOneSubscriptionServiceType]


SKADecryptedStatusPayload : NSObject
 @property  SKStatusPayload *statusPayload
 @property  SKADatabaseReceivedInvitation *invitation

  // instance methods
  -[SKADecryptedStatusPayload .cxx_destruct]
  -[SKADecryptedStatusPayload invitation]
  -[SKADecryptedStatusPayload statusPayload]
  -[SKADecryptedStatusPayload initWithStatusPayload:invitation:]


SKADatabaseInvitedUser : NSObject
 @property  SKHandle *invitedSKHandle
 @property  SKHandle *senderSKHandle
 @property  SKInvitationPayload *invitationPayload
 @property  NSString *invitedHandle
 @property  NSString *senderHandle
 @property  NSData *invitationPayloadData
 @property  NSDate *dateInvitationPayloadCreated

  // instance methods
  -[SKADatabaseInvitedUser .cxx_destruct]
  -[SKADatabaseInvitedUser senderHandle]
  -[SKADatabaseInvitedUser invitationPayload]
  -[SKADatabaseInvitedUser invitedSKHandle]
  -[SKADatabaseInvitedUser senderSKHandle]
  -[SKADatabaseInvitedUser initWithCoreDataInvitedUser:]
  -[SKADatabaseInvitedUser invitedHandle]
  -[SKADatabaseInvitedUser dateInvitationPayloadCreated]
  -[SKADatabaseInvitedUser initWithInvitedHandle:senderHande:invitationPayloadData:dateInvitationPayloadCreated:]
  -[SKADatabaseInvitedUser invitationPayloadData]


SKADatabaseManager : NSObject <SKADatabaseManaging>
 @property  <SKADatabaseProviding> *databaseProvider
 @property  <SKADatabaseManagingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKADatabaseManager logger]

  // instance methods
  -[SKADatabaseManager existingRecentTransientSubscriptionHistoriesWithLimit:databaseContext:]
  -[SKADatabaseManager createPendingPublishRequestWithUniqueIdentifier:dateCreated:payloadData:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager databaseProvider]
  -[SKADatabaseManager _existingTransientSubscriptionHistoryWithLimit:orderedByLastSubscriptionDateAscending:databaseContext:]
  -[SKADatabaseManager _existingInvitedUsersForInvitedHandle:channel:databaseContext:]
  -[SKADatabaseManager existingPendingPublishRequestForUniqueIdentifier:withDatabaseContext:]
  -[SKADatabaseManager deleteInvitedUserForHandle:personalChannel:databaseContext:]
  -[SKADatabaseManager .cxx_destruct]
  -[SKADatabaseManager allExistingChannelsForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager updatePersonalChannel:withCurrentOutgoingRatchetState:databaseContext:]
  -[SKADatabaseManager copyInvitedUsersFromChannel:toChannel:databaseContext:]
  -[SKADatabaseManager _existingPendingPublishRequestsForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager _existingPendingPublishRequestForUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager initWithDatabaseProvider:delegate:]
  -[SKADatabaseManager allPersistentSubscriptionAssertionChannelIdentifiersWithDatabaseContext:]
  -[SKADatabaseManager existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager receivedInvitationsForChannel:databaseContext:]
  -[SKADatabaseManager _existingPersonalChannelForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager createRemovedUserWithHandle:dateRemoved:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager existingInvitedUsersForPersonalChannel:databaseContext:]
  -[SKADatabaseManager cleanupDecommisionedChannelsWithDatabaseContext:]
  -[SKADatabaseManager decomissionAllPersonalChannelsWithStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager deleteSubscriptionAssertionWithSubscriptionIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager deviceToDeviceEncryptedDatabaseCapableWithCompletion:]
  -[SKADatabaseManager createStatusWithUniqueIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:channelIdentifier:databaseContext:]
  -[SKADatabaseManager existingStatusForChannel:databaseContext:]
  -[SKADatabaseManager allExistingChannelsForStatusTypeIdentifier:includingPersonalChannel:databaseContext:]
  -[SKADatabaseManager incrementPendingPublishRequestRetryCountWithUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager existingPendingPublishRequestsWithDatabaseContext:]
  -[SKADatabaseManager _existingChannelsForChannelIdentifier:databaseContext:]
  -[SKADatabaseManager deletePersonalChannelForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager existingInvitedUsersForInvitedHandle:onChannel:databaseContext:]
  -[SKADatabaseManager _existingReceivedInvitationsForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingChannelsForDatabaseChannel:databaseContext:]
  -[SKADatabaseManager _existingPersonalChannelForDatabaseChannel:databaseContext:]
  -[SKADatabaseManager createPersonalChannelForStatusTypeIdentifier:channelIdentifier:channelToken:databaseContext:]
  -[SKADatabaseManager existingChannelForSubscriptionIdentifier:databaseContext:]
  -[SKADatabaseManager cleanupOldStatusUpdatesForChannelIdentifier:excludingStatusUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager _existingTransientSubscriptionHistoryForChannelIdentifier:databaseContext:]
  -[SKADatabaseManager _existingInvitedUsersForDatabaseInvitedUser:databaseChannel:databaseContext:]
  -[SKADatabaseManager delegate]
  -[SKADatabaseManager deleteAllInvitedUsersForPersonalChannel:databaseContext:]
  -[SKADatabaseManager _existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager cleanupOldChannelsForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager createOrUpdateTransientSubscriptionHistoryForChannelIdentifier:lastSubscriptionDate:databaseContext:]
  -[SKADatabaseManager _existingPendingPublishRequestsWithDatabaseContext:]
  -[SKADatabaseManager createInvitedUserWithHandle:senderHandle:invitationPayload:channel:databaseContext:]
  -[SKADatabaseManager deletePendingPublishRequestWithWithUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager existingStatusForUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager existingPersonalChannelForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager cleanupOldReceivedInvitationsForChannelIdentifier:excludingInvitation:databaseContext:]
  -[SKADatabaseManager _existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager createReceivedInvitationForChannel:senderHandle:invitedHandle:invitationIdentifier:dateInvitationCreated:incomingRatchetState:invitationPayload:databaseContext:]
  -[SKADatabaseManager _existingRemovedUsersForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingPersonalChannelsForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager newBackgroundContext]
  -[SKADatabaseManager existingChannelForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager deleteRemovedUserWithHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager createChannelForStatusTypeIdentifier:channelIdentifier:databaseContext:]
  -[SKADatabaseManager updateInvitationPayload:onExistingInvitedUser:channel:databaseContext:]
  -[SKADatabaseManager createSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager existingRemovedUserWithHandle:statusTypeIdentifier:withDatabaseContext:]
  -[SKADatabaseManager _existingDecomissionedPersonalChannelsWithDatabaseContext:]
  -[SKADatabaseManager existingPendingPublishRequestsForStatusTypeIdentifier:withDatabaseContext:]
  -[SKADatabaseManager generatedEncryptionKeysForPersonalChannel:databaseContext:]
  -[SKADatabaseManager createGeneratedEncryptionKeyWithOriginalOutgoingRatchetState:personalChannel:databaseContext:]
  -[SKADatabaseManager _existingReceivedInvitationsForChannelIdentifier:sortedByDateReceived:databaseContect:]


SKADatabaseSubscriptionAssertion : NSObject
 @property  NSString *channelIdentifier
 @property  NSString *statusTypeIdentifier
 @property  NSString *applicationIdentifier

  // instance methods
  -[SKADatabaseSubscriptionAssertion applicationIdentifier]
  -[SKADatabaseSubscriptionAssertion .cxx_destruct]
  -[SKADatabaseSubscriptionAssertion statusTypeIdentifier]
  -[SKADatabaseSubscriptionAssertion channelIdentifier]
  -[SKADatabaseSubscriptionAssertion initWithChannelIdentifier:statusTypeIdentifier:applicationIdentifier:]
  -[SKADatabaseSubscriptionAssertion initWithCoreDataSubscriptionAssertion:]


SKADatabasePendingPublishRequest : NSObject
 @property  NSString *statusTypeIdentifier
 @property  NSDate *dateCreated
 @property  NSData *payloadData
 @property  NSString *statusUniqueIdentifier
 @property  long long retryCount

  // instance methods
  -[SKADatabasePendingPublishRequest .cxx_destruct]
  -[SKADatabasePendingPublishRequest payloadData]
  -[SKADatabasePendingPublishRequest statusTypeIdentifier]
  -[SKADatabasePendingPublishRequest dateCreated]
  -[SKADatabasePendingPublishRequest retryCount]
  -[SKADatabasePendingPublishRequest statusUniqueIdentifier]
  -[SKADatabasePendingPublishRequest initWithStatusTypeIdentifier:dateCreated:payloadData:statusUniqueIdentifier:retryCount:]
  -[SKADatabasePendingPublishRequest initWithCoreDataPendingPublishRequest:]


SKASystemMonitor : NSObject
 @property  {os_unfair_lock_s=I} ivarLock
 @property  BOOL underFirstLock
 @property  NSHashTable *listeners
 @property  BOOL isUnderFirstDataProtectionLock

  // class methods
  +[SKASystemMonitor logger]
  +[SKASystemMonitor sharedInstance]

  // instance methods
  -[SKASystemMonitor removeListener:]
  -[SKASystemMonitor setListeners:]
  -[SKASystemMonitor .cxx_destruct]
  -[SKASystemMonitor setIvarLock:]
  -[SKASystemMonitor init]
  -[SKASystemMonitor ivarLock]
  -[SKASystemMonitor _updateLockState]
  -[SKASystemMonitor listeners]
  -[SKASystemMonitor _deviceStillUnderFirstLock]
  -[SKASystemMonitor addListener:]
  -[SKASystemMonitor isUnderFirstDataProtectionLock]
  -[SKASystemMonitor _listenForKeyBagChangeNotifications]
  -[SKASystemMonitor _deliverNotificationSelectorToListeners:]
  -[SKASystemMonitor underFirstLock]
  -[SKASystemMonitor setUnderFirstLock:]


Channel : NSManagedObject
 @property  NSData *channelToken
 @property  NSData *currentOutgoingRatchetState
 @property  NSDate *dateChannelCreated
 @property  BOOL decomissioned
 @property  NSString *identifier
 @property  BOOL personal
 @property  NSString *statusType
 @property  NSSet *generatedEncryptionKeys
 @property  NSSet *invitedUsers
 @property  NSSet *receivedInvitations

  // class methods
  +[Channel predicateForPersonal:]
  +[Channel predicateForChannelIdentifier:]
  +[Channel predicateForStatusTypeIdentifier:]
  +[Channel fetchRequest]
  +[Channel personalKeyPath]
  +[Channel sortDescriptorForStatusTypeIdentifierOrderedAscending:]
  +[Channel sortDescriptorForPersonalOrderedAscending:]
  +[Channel decomissionedKeyPath]
  +[Channel identifierKeyPath]
  +[Channel predicateForCreationDateNotNil]
  +[Channel predicateForDecomissioned:]
  +[Channel statusTypeKeyPath]
  +[Channel sortDescriptorForCreationDateAscending:]
  +[Channel dateChannelCreatedKeyPath]
  +[Channel sortDescriptorForChannelIdentifierOrderedAscending:]
  +[Channel encryptionKeysKeyPath]


GeneratedEncryptionKey : NSManagedObject
 @property  NSDate *dateGenerated
 @property  NSData *originalOutgoingRatchetState
 @property  Channel *channel

  // class methods
  +[GeneratedEncryptionKey fetchRequest]
  +[GeneratedEncryptionKey dateGeneratedKeyPath]


InvitedUser : NSManagedObject
 @property  NSDate *dateInvitationPayloadCreated
 @property  NSData *invitationPayload
 @property  NSString *invitedHandle
 @property  NSString *senderHandle
 @property  Channel *channel

  // class methods
  +[InvitedUser fetchRequest]
  +[InvitedUser senderHandleKeyPath]
  +[InvitedUser predicateForSenderHandle:]
  +[InvitedUser predicateForInvitedHandle:]
  +[InvitedUser predicateForChannel:]
  +[InvitedUser invitedHandleKeyPath]
  +[InvitedUser channelKeyPath]


PendingPublishRequest : NSManagedObject
 @property  NSDate *dateCreated
 @property  NSData *payloadData
 @property  int retryCount
 @property  NSString *statusTypeIdentifier
 @property  NSString *statusUniqueIdentifier

  // class methods
  +[PendingPublishRequest predicateForStatusTypeIdentifier:]
  +[PendingPublishRequest fetchRequest]
  +[PendingPublishRequest statusTypeIdentifierKeyPath]
  +[PendingPublishRequest dateCreatedKeyPath]
  +[PendingPublishRequest statusUniqueIdentifierKeyPath]
  +[PendingPublishRequest predicateForStatusUniqueIdentifier:]
  +[PendingPublishRequest sortDescriptorForDateCreatedAscending:]


ReceivedInvitation : NSManagedObject
 @property  NSDate *dateInvitationCreated
 @property  NSData *incomingRatchetState
 @property  NSString *invitationIdentifier
 @property  NSData *invitationPayload
 @property  NSString *invitedHandle
 @property  NSString *senderHandle
 @property  NSString *statusTypeIdentifier
 @property  Channel *channel

  // class methods
  +[ReceivedInvitation predicateForStatusTypeIdentifier:]
  +[ReceivedInvitation fetchRequest]
  +[ReceivedInvitation statusTypeIdentifierKeyPath]
  +[ReceivedInvitation dateInvitationCreatedKeyPath]
  +[ReceivedInvitation senderHandleKeyPath]
  +[ReceivedInvitation predicateForSenderHandleString:]
  +[ReceivedInvitation predicateForSenderHandle:]
  +[ReceivedInvitation sortDescriptorForDateInvitationCreatedOrderedAscending:]
  +[ReceivedInvitation sortDescriptorForSenderHandleOrderedAscending:]


RemovedUser : NSManagedObject
 @property  NSDate *dateRemoved
 @property  NSString *removedHandle
 @property  NSString *statusTypeIdentifier

  // class methods
  +[RemovedUser predicateForStatusTypeIdentifier:]
  +[RemovedUser fetchRequest]
  +[RemovedUser predicateForHandle:]
  +[RemovedUser dateRemovedKeyPath]
  +[RemovedUser handleKeyPath]
  +[RemovedUser statusTypeIdentifierKeyPath]
  +[RemovedUser predicateForHandleString:]


Status : NSManagedObject
 @property  NSString *channelIdentifier
 @property  NSDate *dateCreated
 @property  NSDate *dateExpired
 @property  NSDate *datePublished
 @property  NSDate *dateReceived
 @property  NSData *rawData
 @property  NSString *uniqueIdentifier

  // class methods
  +[Status predicateForChannelIdentifier:]
  +[Status fetchRequest]
  +[Status channelIdentifierKeyPath]
  +[Status dateCreatedKeyPath]
  +[Status predicateForStatusUniqueIdentifier:]
  +[Status sortDescriptorForDateCreatedAscending:]
  +[Status datePublishedKeyPath]
  +[Status uniqueIdentifierKeyPath]
  +[Status sortDescriptorForDatePublishedAscending:]


SubscriptionAssertion : NSManagedObject
 @property  NSString *applicationIdentifier
 @property  NSString *channelIdentifier
 @property  NSString *statusTypeIdentifier

  // class methods
  +[SubscriptionAssertion predicateForChannelIdentifier:]
  +[SubscriptionAssertion predicateForStatusTypeIdentifier:]
  +[SubscriptionAssertion fetchRequest]
  +[SubscriptionAssertion channelIdentifierKeyPath]
  +[SubscriptionAssertion statusTypeIdentifierKeyPath]
  +[SubscriptionAssertion applicationIdentifierKeyPath]
  +[SubscriptionAssertion predicateForApplicationIdentifier:]


TransientSubscriptionHistory : NSManagedObject
 @property  NSString *channelIdentifier
 @property  NSDate *lastSubscriptionDate

  // class methods
  +[TransientSubscriptionHistory predicateForChannelIdentifier:]
  +[TransientSubscriptionHistory fetchRequest]
  +[TransientSubscriptionHistory sortDescriptorForLastSubscriptionDateAscending:]
  +[TransientSubscriptionHistory lastSubscriptionDateKeyPath]
  +[TransientSubscriptionHistory predicateForLastSubscriptionDate:]
  +[TransientSubscriptionHistory channelIdentifierKeyPath]


(StatusKitAgent)
	// instance methods
	-[(StatusKitAgent) ska_dataFrombase64EncodedStringForKey:]
	-[(StatusKitAgent) ska_numberForKey:]
	-[(StatusKitAgent) ska_stringForKey:]
	-[(StatusKitAgent) ska_dateFromUnixTimestampForKey:]
	-[(StatusKitAgent) ska_dictionaryForKey:]

SKHandle(StatusKitAgent)
	// instance methods
	-[SKHandle(StatusKitAgent) idsDestination]
	-[SKHandle(StatusKitAgent) isNormalizedEqualToHandle:]
	-[SKHandle(StatusKitAgent) normalizedHandleString]

NSXPCConnection(StatusKitAgent)
	// instance methods
	-[NSXPCConnection(StatusKitAgent) sk_stringArrayValueForEntitlement:]
	-[NSXPCConnection(StatusKitAgent) sk_booleanValueForEntitlement:]

(StatusKitAgent)
	// instance methods
	-[(StatusKitAgent) ska_hexString]

(StatusKitAgent)
	// instance methods
	-[(StatusKitAgent) ska_sha256Hash]
	-[(StatusKitAgent) ska_appearsToBeEmail]

01 00 0800 /System/Library/Frameworks/Accounts.framework/Accounts: ACAccountStore 
01 00 0a00 /System/Library/PrivateFrameworks/AuthKit.framework/AuthKit: AKAppleIDAuthenticationContext 
01 00 0a00 /System/Library/PrivateFrameworks/AuthKit.framework/AuthKit: AKAppleIDAuthenticationController 
01 00 0500 /System/Library/PrivateFrameworks/ApplePushService.framework/ApplePushService: APSConnection 
01 00 0d00 /System/Library/PrivateFrameworks/BiomeStreams.framework/BiomeStreams: BMStreams 
01 00 0d00 /System/Library/PrivateFrameworks/BiomeStreams.framework/BiomeStreams: BMUserStatusChangeEvent 
01 00 0900 /System/Library/Frameworks/CloudKit.framework/CloudKit: CKContainer 
01 00 0900 /System/Library/Frameworks/CloudKit.framework/CloudKit: CKContainerID 
01 00 0600 /System/Library/PrivateFrameworks/FTServices.framework/FTServices: FTMessageDelivery_APS 
01 00 0600 /System/Library/PrivateFrameworks/FTServices.framework/FTServices: FTShareChannelMessage 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSIDQueryController 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSServerBag 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSService 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSURI 
01 00 0c00 /System/Library/PrivateFrameworks/MessageProtection.framework/MessageProtection: MPStatusKitIncomingRatchet 
01 00 0c00 /System/Library/PrivateFrameworks/MessageProtection.framework/MessageProtection: MPStatusKitOutgoingRatchet 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSArray 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSBundle 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSCompoundPredicate 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSConstantArray 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSConstantIntegerNumber 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSData 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSDate 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSDictionary 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSError 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSFetchRequest 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSFileManager 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSHashTable 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSJSONSerialization 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSKeyedArchiver 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSKeyedUnarchiver 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSManagedObject 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSManagedObjectModel 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSMapTable 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableArray 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableDictionary 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSMutableIndexSet 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableOrderedSet 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableSet 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSMutableString 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSNotificationCenter 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSNumber 
01 00 1000 /usr/lib/libobjc.A.dylib: NSObject 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentCloudKitContainer 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentCloudKitContainerOptions 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentHistoryChangeRequest 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentHistoryToken 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentHistoryTransaction 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentStoreDescription 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSPredicate 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSPropertyListSerialization 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSSet 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSSortDescriptor 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSString 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSUUID 
01 00 1200 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSUserDefaults 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSXPCConnection 
01 00 0f00 /System/Library/Frameworks/Foundation.framework/Foundation: NSXPCListener 
01 00 0300 /System/Library/PrivateFrameworks/ProtocolBuffer.framework/ProtocolBuffer: PBCodable 
01 00 0300 /System/Library/PrivateFrameworks/ProtocolBuffer.framework/ProtocolBuffer: PBRequest 
01 00 0400 /System/Library/Frameworks/PushKit.framework/PushKit: PKPublicChannel 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKHandle 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKHandleInvitability 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKInvitationPayload 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKPublishedStatus 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusPayload 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusPublishRequest 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusPublishingDaemonConnection 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusSubscriptionDaemonConnection 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusSubscriptionMetadata 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKSubscriptionValidationTokens 
