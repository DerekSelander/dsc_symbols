|| __DATA.__data _SKAChannelManagerErrorRetryIntervalKey
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseChannel
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseInvitedUser
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabasePendingPublishRequest
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseReceivedInvitation
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseRemovedUser
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseStatus
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseSubscriptionAssertion
|| __DATA.__objc_data _OBJC_CLASS_$_SKADatabaseTransientSubscriptionHistory
|| __DATA.__objc_data _OBJC_CLASS_$_SKAGeneratedEncryptionKey
|| __DATA.__objc_data _OBJC_CLASS_$_SKAStatusPublishingServiceClient
|| __DATA.__objc_data _OBJC_CLASS_$_SKAStatusPublishingServiceClientConnection
|| __DATA.__objc_data _OBJC_CLASS_$_SKAStatusUnencryptedEnvelope
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseChannel
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseInvitedUser
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabasePendingPublishRequest
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseReceivedInvitation
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseRemovedUser
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseStatus
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseSubscriptionAssertion
|| __DATA.__objc_data _OBJC_METACLASS_$_SKADatabaseTransientSubscriptionHistory
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAGeneratedEncryptionKey
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAStatusPublishingServiceClient
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAStatusPublishingServiceClientConnection
|| __DATA.__objc_data _OBJC_METACLASS_$_SKAStatusUnencryptedEnvelope
|| __DATA_CONST.__const _SKAAccountProviderErrorDomain
|| __DATA_CONST.__const _SKAChannelManagerErrorDomain
|| __DATA_CONST.__const _SKPushManagerErrorDomain
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAAccountProvider
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAChannelManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKADatabaseManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKADatabaseProvider
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAInvitationManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAMessagingProvider
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAPresenceClient
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAPresenceClientConnection
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAPresenceManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAPushManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusEncryptionManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusPublishingManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusReceivingManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusServer
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusSubscriptionManager
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusSubscriptionServiceClient
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKAStatusSubscriptionServiceClientConnection
|| __DATA_DIRTY.__objc_data _OBJC_CLASS_$_SKASystemMonitor
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAAccountProvider
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAChannelManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKADatabaseManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKADatabaseProvider
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAInvitationManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAMessagingProvider
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAPresenceClient
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAPresenceClientConnection
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAPresenceManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAPushManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusEncryptionManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusPublishingManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusReceivingManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusServer
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusSubscriptionManager
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusSubscriptionServiceClient
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKAStatusSubscriptionServiceClientConnection
|| __DATA_DIRTY.__objc_data _OBJC_METACLASS_$_SKASystemMonitor
__ Accounts: _OBJC_CLASS_$_ACAccountStore
__ ApplePushService: _APSConnectionOverrideNamedDelegatePort
__ ApplePushService: _APSEnvironmentDevelopment
__ ApplePushService: _APSEnvironmentProduction
__ ApplePushService: _OBJC_CLASS_$_APSConnection
__ AuthKit: _OBJC_CLASS_$_AKAppleIDAuthenticationContext
__ AuthKit: _OBJC_CLASS_$_AKAppleIDAuthenticationController
__ BiomeStreams: _OBJC_CLASS_$_BMStreams
__ BiomeStreams: _OBJC_CLASS_$_BMUserStatusChangeEvent
__ CloudKit: _OBJC_CLASS_$_CKContainer
__ CloudKit: _OBJC_CLASS_$_CKContainerID
__ CoreData: _NSInferMappingModelAutomaticallyOption
__ CoreData: _NSMigratePersistentStoresAutomaticallyOption
__ CoreData: _NSPersistentHistoryTrackingKey
__ CoreData: _NSPersistentStoreRemoteChangeNotification
__ CoreData: _NSPersistentStoreRemoteChangeNotificationPostOptionKey
__ CoreData: _NSSQLiteStoreType
__ CoreData: _OBJC_CLASS_$_NSFetchRequest
__ CoreData: _OBJC_CLASS_$_NSManagedObject
__ CoreData: _OBJC_CLASS_$_NSManagedObjectModel
__ CoreData: _OBJC_CLASS_$_NSPersistentCloudKitContainer
__ CoreData: _OBJC_CLASS_$_NSPersistentCloudKitContainerOptions
__ CoreData: _OBJC_CLASS_$_NSPersistentHistoryChangeRequest
__ CoreData: _OBJC_CLASS_$_NSPersistentHistoryToken
__ CoreData: _OBJC_CLASS_$_NSPersistentHistoryTransaction
__ CoreData: _OBJC_CLASS_$_NSPersistentStoreDescription
__ CoreData: _OBJC_METACLASS_$_NSManagedObject
__ CoreFoundation: _CFPreferencesCopyAppValue
__ CoreFoundation: _CFPreferencesGetAppBooleanValue
__ CoreFoundation: _CFPreferencesSetAppValue
__ CoreFoundation: _OBJC_CLASS_$_NSArray
__ CoreFoundation: _OBJC_CLASS_$_NSConstantArray
__ CoreFoundation: _OBJC_CLASS_$_NSData
__ CoreFoundation: _OBJC_CLASS_$_NSDate
__ CoreFoundation: _OBJC_CLASS_$_NSDictionary
__ CoreFoundation: _OBJC_CLASS_$_NSMutableArray
__ CoreFoundation: _OBJC_CLASS_$_NSMutableData
__ CoreFoundation: _OBJC_CLASS_$_NSMutableDictionary
__ CoreFoundation: _OBJC_CLASS_$_NSMutableOrderedSet
__ CoreFoundation: _OBJC_CLASS_$_NSMutableSet
__ CoreFoundation: _OBJC_CLASS_$_NSSet
__ CoreFoundation: _OBJC_CLASS_$_NSUserDefaults
__ CoreFoundation: ___CFConstantStringClassReference
__ CoreFoundation: ___NSArray0__struct
__ CoreFoundation: ___kCFBooleanFalse
__ CoreFoundation: ___kCFBooleanTrue
__ FTServices: _OBJC_CLASS_$_FTMessageDelivery_APS
__ FTServices: _OBJC_CLASS_$_FTProtobufMessage
__ FTServices: _OBJC_CLASS_$_FTShareChannelMessage
__ Foundation: _NSClassFromString
__ Foundation: _NSCocoaErrorDomain
__ Foundation: _NSDebugDescriptionErrorKey
__ Foundation: _NSGlobalDomain
__ Foundation: _NSLocalizedDescriptionKey
__ Foundation: _NSStringFromClass
__ Foundation: _NSStringFromSelector
__ Foundation: _NSUnderlyingErrorKey
__ Foundation: _OBJC_CLASS_$_NSBundle
__ Foundation: _OBJC_CLASS_$_NSCompoundPredicate
__ Foundation: _OBJC_CLASS_$_NSConstantIntegerNumber
__ Foundation: _OBJC_CLASS_$_NSError
__ Foundation: _OBJC_CLASS_$_NSFileManager
__ Foundation: _OBJC_CLASS_$_NSHashTable
__ Foundation: _OBJC_CLASS_$_NSJSONSerialization
__ Foundation: _OBJC_CLASS_$_NSKeyedArchiver
__ Foundation: _OBJC_CLASS_$_NSKeyedUnarchiver
__ Foundation: _OBJC_CLASS_$_NSMapTable
__ Foundation: _OBJC_CLASS_$_NSMutableIndexSet
__ Foundation: _OBJC_CLASS_$_NSMutableString
__ Foundation: _OBJC_CLASS_$_NSNotificationCenter
__ Foundation: _OBJC_CLASS_$_NSNumber
__ Foundation: _OBJC_CLASS_$_NSPredicate
__ Foundation: _OBJC_CLASS_$_NSPropertyListSerialization
__ Foundation: _OBJC_CLASS_$_NSSortDescriptor
__ Foundation: _OBJC_CLASS_$_NSString
__ Foundation: _OBJC_CLASS_$_NSUUID
__ Foundation: _OBJC_CLASS_$_NSXPCConnection
__ Foundation: _OBJC_CLASS_$_NSXPCListener
__ IDS: _IDSCopyIDForEmailAddress
__ IDS: _IDSCopyIDForPhoneNumber
__ IDS: _IDSCopyIDForTokenWithID
__ IDS: _IDSCopyRawAddressForDestination
__ IDS: _IDSCopyTokenAndIDForTokenWithID
__ IDS: _IDSSendMessageOptionFromIDKey
__ IDS: _OBJC_CLASS_$_IDSIDQueryController
__ IDS: _OBJC_CLASS_$_IDSServerBag
__ IDS: _OBJC_CLASS_$_IDSService
__ IDS: _OBJC_CLASS_$_IDSURI
__ IDS: __IDSCopyCallerID
__ IDS: __IDSCopyOrderedAliases
__ MessageProtection: _OBJC_CLASS_$_MPStatusKitIncomingRatchet
__ MessageProtection: _OBJC_CLASS_$_MPStatusKitOutgoingRatchet
__ MobileKeyBag: _MKBDeviceUnlockedSinceBoot
__ MobileKeyBag: _kMobileKeyBagLockStatusNotifyToken
__ ProtocolBuffer: _OBJC_CLASS_$_PBCodable
__ ProtocolBuffer: _OBJC_CLASS_$_PBRequest
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._bytes
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._error
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._length
__ ProtocolBuffer: _OBJC_IVAR_$_PBDataReader._pos
__ ProtocolBuffer: _OBJC_METACLASS_$_PBCodable
__ ProtocolBuffer: _OBJC_METACLASS_$_PBRequest
__ ProtocolBuffer: _PBDataWriterWriteBOOLField
__ ProtocolBuffer: _PBDataWriterWriteDataField
__ ProtocolBuffer: _PBDataWriterWriteInt32Field
__ ProtocolBuffer: _PBDataWriterWriteStringField
__ ProtocolBuffer: _PBDataWriterWriteSubmessage
__ ProtocolBuffer: _PBDataWriterWriteUint32Field
__ ProtocolBuffer: _PBDataWriterWriteUint64Field
__ ProtocolBuffer: _PBReaderPlaceMark
__ ProtocolBuffer: _PBReaderReadData
__ ProtocolBuffer: _PBReaderReadString
__ ProtocolBuffer: _PBReaderRecallMark
__ ProtocolBuffer: _PBReaderSkipValueWithTag
__ PushKit: _OBJC_CLASS_$_PKPublicChannel
__ Security: _SecKeyCopyExternalRepresentation
__ Security: _SecKeyCopyPublicKey
__ Security: _SecKeyCreateRandomKey
__ Security: _SecKeyCreateSignature
__ Security: _SecKeyCreateWithData
__ Security: _kSecAttrIsPermanent
__ Security: _kSecAttrKeyClass
__ Security: _kSecAttrKeyClassPrivate
__ Security: _kSecAttrKeySizeInBits
__ Security: _kSecAttrKeyType
__ Security: _kSecAttrKeyTypeECSECPrimeRandom
__ Security: _kSecKeyAlgorithmECDSASignatureMessageX962SHA256
__ StatusKit: _OBJC_CLASS_$_SKHandle
__ StatusKit: _OBJC_CLASS_$_SKHandleInvitability
__ StatusKit: _OBJC_CLASS_$_SKInvitationPayload
__ StatusKit: _OBJC_CLASS_$_SKPresenceDaemonConnection
__ StatusKit: _OBJC_CLASS_$_SKPresentDevice
__ StatusKit: _OBJC_CLASS_$_SKPublishedStatus
__ StatusKit: _OBJC_CLASS_$_SKStatusPayload
__ StatusKit: _OBJC_CLASS_$_SKStatusPublishRequest
__ StatusKit: _OBJC_CLASS_$_SKStatusPublishingDaemonConnection
__ StatusKit: _OBJC_CLASS_$_SKStatusSubscriptionDaemonConnection
__ StatusKit: _OBJC_CLASS_$_SKStatusSubscriptionMetadata
__ StatusKit: _OBJC_CLASS_$_SKSubscriptionValidationTokens
__ StatusKit: _SKPresenceErrorDomain
__ StatusKit: _SKStatusPublishingErrorDomain
__ StatusKit: _SKStatusSubscriptionErrorDomain
__ libSystem.B.dylib: _CCCryptorGCMOneshotDecrypt
__ libSystem.B.dylib: _CCCryptorGCMOneshotEncrypt
__ libSystem.B.dylib: _CCRandomGenerateBytes
__ libSystem.B.dylib: _CC_SHA256
__ libSystem.B.dylib: _XPC_ACTIVITY_ALLOW_BATTERY
__ libSystem.B.dylib: _XPC_ACTIVITY_CHECK_IN
__ libSystem.B.dylib: _XPC_ACTIVITY_INTERVAL
__ libSystem.B.dylib: _XPC_ACTIVITY_INTERVAL_1_DAY
__ libSystem.B.dylib: _XPC_ACTIVITY_PRIORITY
__ libSystem.B.dylib: _XPC_ACTIVITY_PRIORITY_MAINTENANCE
__ libSystem.B.dylib: _XPC_ACTIVITY_REQUIRE_NETWORK_CONNECTIVITY
__ libSystem.B.dylib: __Block_object_dispose
__ libSystem.B.dylib: __NSConcreteGlobalBlock
__ libSystem.B.dylib: __NSConcreteStackBlock
__ libSystem.B.dylib: __Unwind_Resume
__ libSystem.B.dylib: ___stack_chk_fail
__ libSystem.B.dylib: ___stack_chk_guard
__ libSystem.B.dylib: __dispatch_main_q
__ libSystem.B.dylib: __os_activity_create
__ libSystem.B.dylib: __os_activity_current
__ libSystem.B.dylib: __os_feature_enabled_impl
__ libSystem.B.dylib: __os_log_debug_impl
__ libSystem.B.dylib: __os_log_error_impl
__ libSystem.B.dylib: __os_log_fault_impl
__ libSystem.B.dylib: __os_log_impl
__ libSystem.B.dylib: _arc4random_buf
__ libSystem.B.dylib: _arc4random_uniform
__ libSystem.B.dylib: _dispatch_after
__ libSystem.B.dylib: _dispatch_assert_queue$V2
__ libSystem.B.dylib: _dispatch_async
__ libSystem.B.dylib: _dispatch_once
__ libSystem.B.dylib: _dispatch_queue_attr_make_with_autorelease_frequency
__ libSystem.B.dylib: _dispatch_queue_attr_make_with_qos_class
__ libSystem.B.dylib: _dispatch_queue_create
__ libSystem.B.dylib: _dispatch_semaphore_create
__ libSystem.B.dylib: _dispatch_semaphore_signal
__ libSystem.B.dylib: _dispatch_semaphore_wait
__ libSystem.B.dylib: _dispatch_sync
__ libSystem.B.dylib: _dispatch_time
__ libSystem.B.dylib: _notify_is_valid_token
__ libSystem.B.dylib: _notify_register_dispatch
__ libSystem.B.dylib: _os_log_create
__ libSystem.B.dylib: _os_log_type_enabled
__ libSystem.B.dylib: _os_transaction_create
__ libSystem.B.dylib: _os_unfair_lock_lock
__ libSystem.B.dylib: _os_unfair_lock_unlock
__ libSystem.B.dylib: _strlen
__ libSystem.B.dylib: _xpc_activity_copy_criteria
__ libSystem.B.dylib: _xpc_activity_get_state
__ libSystem.B.dylib: _xpc_activity_register
__ libSystem.B.dylib: _xpc_activity_set_criteria
__ libSystem.B.dylib: _xpc_dictionary_create
__ libSystem.B.dylib: _xpc_dictionary_set_bool
__ libSystem.B.dylib: _xpc_dictionary_set_int64
__ libSystem.B.dylib: _xpc_dictionary_set_string
__ libSystem.B.dylib: _xpc_equal
__ libobjc.A.dylib: _OBJC_CLASS_$_NSObject
__ libobjc.A.dylib: _OBJC_METACLASS_$_NSObject
__ libobjc.A.dylib: ___objc_personality_v0
__ libobjc.A.dylib: __objc_empty_cache
__ libobjc.A.dylib: _objc_alloc
__ libobjc.A.dylib: _objc_alloc_init
__ libobjc.A.dylib: _objc_autorelease
__ libobjc.A.dylib: _objc_autoreleasePoolPop
__ libobjc.A.dylib: _objc_autoreleasePoolPush
__ libobjc.A.dylib: _objc_autoreleaseReturnValue
__ libobjc.A.dylib: _objc_claimAutoreleasedReturnValue
__ libobjc.A.dylib: _objc_copyWeak
__ libobjc.A.dylib: _objc_destroyWeak
__ libobjc.A.dylib: _objc_enumerationMutation
__ libobjc.A.dylib: _objc_initWeak
__ libobjc.A.dylib: _objc_loadWeakRetained
__ libobjc.A.dylib: _objc_msgSend
__ libobjc.A.dylib: _objc_msgSendSuper2
__ libobjc.A.dylib: _objc_opt_class
__ libobjc.A.dylib: _objc_opt_isKindOfClass
__ libobjc.A.dylib: _objc_opt_respondsToSelector
__ libobjc.A.dylib: _objc_opt_self
__ libobjc.A.dylib: _objc_release
__ libobjc.A.dylib: _objc_release_x1
__ libobjc.A.dylib: _objc_release_x19
__ libobjc.A.dylib: _objc_release_x20
__ libobjc.A.dylib: _objc_release_x21
__ libobjc.A.dylib: _objc_release_x22
__ libobjc.A.dylib: _objc_release_x23
__ libobjc.A.dylib: _objc_release_x24
__ libobjc.A.dylib: _objc_release_x25
__ libobjc.A.dylib: _objc_release_x26
__ libobjc.A.dylib: _objc_release_x27
__ libobjc.A.dylib: _objc_release_x28
__ libobjc.A.dylib: _objc_release_x8
__ libobjc.A.dylib: _objc_release_x9
__ libobjc.A.dylib: _objc_retain
__ libobjc.A.dylib: _objc_retainAutorelease
__ libobjc.A.dylib: _objc_retainAutoreleaseReturnValue
__ libobjc.A.dylib: _objc_retain_x1
__ libobjc.A.dylib: _objc_retain_x19
__ libobjc.A.dylib: _objc_retain_x2
__ libobjc.A.dylib: _objc_retain_x20
__ libobjc.A.dylib: _objc_retain_x21
__ libobjc.A.dylib: _objc_retain_x22
__ libobjc.A.dylib: _objc_retain_x23
__ libobjc.A.dylib: _objc_retain_x24
__ libobjc.A.dylib: _objc_retain_x25
__ libobjc.A.dylib: _objc_retain_x26
__ libobjc.A.dylib: _objc_retain_x27
__ libobjc.A.dylib: _objc_retain_x28
__ libobjc.A.dylib: _objc_retain_x3
__ libobjc.A.dylib: _objc_retain_x4
__ libobjc.A.dylib: _objc_retain_x6
__ libobjc.A.dylib: _objc_retain_x8
__ libobjc.A.dylib: _objc_retain_x9
__ libobjc.A.dylib: _objc_storeStrong
__ libobjc.A.dylib: _objc_storeWeak
__ libobjc.A.dylib: _objc_sync_enter
__ libobjc.A.dylib: _objc_sync_exit
__ libobjc.A.dylib: _objc_unsafeClaimAutoreleasedReturnValue
SKAStatusEncryptionManager : NSObject <SKAStatusEncryptionManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAInvitationManaging> *invitationManager
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusEncryptionManager logger]

  // instance methods
  -[SKAStatusEncryptionManager databaseManager]
  -[SKAStatusEncryptionManager invitationManager]
  -[SKAStatusEncryptionManager initWithDatabaseManager:invitationManager:]
  -[SKAStatusEncryptionManager _decryptPayload:withRatchetIndex:signatureData:channel:]
  -[SKAStatusEncryptionManager _encryptPayload:channel:]
  -[SKAStatusEncryptionManager .cxx_destruct]
  -[SKAStatusEncryptionManager _serializeDictionaryAsBinaryPlist:]
  -[SKAStatusEncryptionManager encryptionValidationTokenForChannel:]
  -[SKAStatusEncryptionManager _mostRecentIncomingRatchetForChannel:]
  -[SKAStatusEncryptionManager extractEnvelopeFromStatusEnvelopeData:]
  -[SKAStatusEncryptionManager _deserializeBinaryPlistDictionaryData:]
  -[SKAStatusEncryptionManager decryptStatusPayloadFromStatusEnvelopeData:channel:]
  -[SKAStatusEncryptionManager encodeStatusPayload:statusUniqueIdentifier:dateCreated:currentServerTime:channel:]
  -[SKAStatusEncryptionManager _decryptPayloadData:withIncomingRatchet:withRatchetIndex:signatureData:]


SKAStatusUnencryptedEnvelope : NSObject
 @property  NSDictionary *envelopeDictionary
 @property  NSString *statusUniqueIdentifier
 @property  NSDate *datePublished
 @property  NSDate *dateCreated

  // instance methods
  -[SKAStatusUnencryptedEnvelope dateCreated]
  -[SKAStatusUnencryptedEnvelope .cxx_destruct]
  -[SKAStatusUnencryptedEnvelope initWithEnvelopeDictionary:]
  -[SKAStatusUnencryptedEnvelope envelopeDictionary]
  -[SKAStatusUnencryptedEnvelope datePublished]
  -[SKAStatusUnencryptedEnvelope statusUniqueIdentifier]
  -[SKAStatusUnencryptedEnvelope setEnvelopeDictionary:]


SKAInvitationManager : NSObject <SKAInvitationManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAMessagingProviding> *messagingProvider
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAAccountProviding> *accountProvider
 @property  <SKAPresenceManaging> *presenceManager
 @property  NSObject<OS_dispatch_queue> *backgroundCleanupQueue
 @property  BOOL trafficModeEnabled
 @property  <SKAInvitationManagingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAInvitationManager logger]
  +[SKAInvitationManager _noPersonalChannelErrorForStatusTypeIdentifier:]
  +[SKAInvitationManager _invalidSenderHandleError]
  +[SKAInvitationManager _invalidInvitedHandlesError]
  +[SKAInvitationManager _noPresenceChannelForIdentifier:]
  +[SKAInvitationManager _keyRollFailedErrorWithUnderlyingError:]
  +[SKAInvitationManager _unableToFindExistingInvitationForHandlesError:]
  +[SKAInvitationManager _unableToFindAnyExistingInvitationToDeleteError]

  // instance methods
  -[SKAInvitationManager revokeAllInvitationsFromPersonalChannelWithStatusTypeIdentifier:completion:]
  -[SKAInvitationManager _sendInvitationMessageForPresenceChannel:toInvitedUsers:error:]
  -[SKAInvitationManager databaseManager]
  -[SKAInvitationManager rollPersonalChannelWithStatusTypeIdentifier:completion:]
  -[SKAInvitationManager setDelegate:]
  -[SKAInvitationManager fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:]
  -[SKAInvitationManager rollEncryptionKeyForPersonalChannelWithStatusTypeIdentifier:error:]
  -[SKAInvitationManager rollPresenceChannelWithPresenceIdentifier:completion:]
  -[SKAInvitationManager _addInvitedHandles:senderHandle:toDatabaseForPersonalChannel:withInvitationPayload:databaseContext:]
  -[SKAInvitationManager fetchHandleInvitability:fromHandle:forPresenceIdentifier:completion:]
  -[SKAInvitationManager delegate]
  -[SKAInvitationManager setTrafficModeEnabled:]
  -[SKAInvitationManager handleIncomingInvitationMessage:fromHandle:toHandle:messageGuid:]
  -[SKAInvitationManager _ratchetEncryptionKeyForwardOrKeyRollForPersonalChannel:databaseContext:invitationWasSentViaKeyRoll:error:]
  -[SKAInvitationManager _addInvitedHandles:senderHandle:toDatabaseForPresenceChannel:databaseContext:]
  -[SKAInvitationManager _validateInvitedHandles:]
  -[SKAInvitationManager presenceManager]
  -[SKAInvitationManager _findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAInvitationManager .cxx_destruct]
  -[SKAInvitationManager accountProvider]
  -[SKAInvitationManager _shouldReauthForError:]
  -[SKAInvitationManager _isPresenceHandleInviteable:completion:]
  -[SKAInvitationManager messagingProvider]
  -[SKAInvitationManager revokeInvitationFromPersonalChannelWithStatusTypeIdentifier:forHandles:completion:]
  -[SKAInvitationManager _rollEncryptionKeyForChannel:databaseContext:error:]
  -[SKAInvitationManager _createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAInvitationManager setAccountProvider:]
  -[SKAInvitationManager initWithMessagingProvider:databaseManager:accountProvider:channelManager:presenceManager:trafficMode:]
  -[SKAInvitationManager channelManager]
  -[SKAInvitationManager setChannelManager:]
  -[SKAInvitationManager _isHandleInviteable:completion:]
  -[SKAInvitationManager isPresenceHandleInviteable:fromHandle:completion:]
  -[SKAInvitationManager setMessagingProvider:]
  -[SKAInvitationManager _validateInvitedHandle:]
  -[SKAInvitationManager sendInvitationForPersonalChannelWithStatusTypeIdentifier:toHandles:fromSenderHandle:withInvitationPayload:completion:]
  -[SKAInvitationManager trafficModeEnabled]
  -[SKAInvitationManager isHandleInviteable:fromHandle:completion:]
  -[SKAInvitationManager _sendInvitationMessageForChannel:toInvitedUsers:subscriptionKeys:error:]
  -[SKAInvitationManager setDatabaseManager:]
  -[SKAInvitationManager _updateOrCreateInvitedUserWithHandle:senderHandle:onChannel:withInvitationPayload:databaseContext:]
  -[SKAInvitationManager sendInvitationForPresenceChannelWithPresenceIdentifier:toHandles:fromSenderHandle:completion:]
  -[SKAInvitationManager setPresenceManager:]
  -[SKAInvitationManager backgroundCleanupQueue]
  -[SKAInvitationManager setBackgroundCleanupQueue:]
  -[SKAInvitationManager revokeInvitationFromPresenceChannelWithPresenceIdentifier:forHandles:completion:]
  -[SKAInvitationManager resolveSenderHandleWithPreferredSenderHandle:]


SKAPresenceAssertion : NSObject
 @property  NSObject<OS_os_activity> *osActivity
 @property  NSString *presenceIdentifier

  // class methods
  +[SKAPresenceAssertion logger]

  // instance methods
  -[SKAPresenceAssertion dealloc]
  -[SKAPresenceAssertion .cxx_destruct]
  -[SKAPresenceAssertion isEqual:]
  -[SKAPresenceAssertion osActivity]
  -[SKAPresenceAssertion initWithPresenceIdentifier:]
  -[SKAPresenceAssertion presenceIdentifier]
  -[SKAPresenceAssertion isEqualToPresenceAssertion:]


SharedChannelCreateRequest : PBRequest <NSCopying>
 @property  BOOL hasChannelTopic
 @property  NSString *channelTopic
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelOwnershipType
 @property  int channelOwnershipType

  // instance methods
  -[SharedChannelCreateRequest copyTo:]
  -[SharedChannelCreateRequest .cxx_destruct]
  -[SharedChannelCreateRequest mergeFrom:]
  -[SharedChannelCreateRequest setChannelTopic:]
  -[SharedChannelCreateRequest dictionaryRepresentation]
  -[SharedChannelCreateRequest copyWithZone:]
  -[SharedChannelCreateRequest channelTopic]
  -[SharedChannelCreateRequest readFrom:]
  -[SharedChannelCreateRequest writeTo:]
  -[SharedChannelCreateRequest isEqual:]
  -[SharedChannelCreateRequest hasChannelTopic]
  -[SharedChannelCreateRequest hasAuthCredential]
  -[SharedChannelCreateRequest channelOwnershipType]
  -[SharedChannelCreateRequest setChannelOwnershipType:]
  -[SharedChannelCreateRequest setHasChannelOwnershipType:]
  -[SharedChannelCreateRequest hasChannelOwnershipType]
  -[SharedChannelCreateRequest channelOwnershipTypeAsString:]
  -[SharedChannelCreateRequest StringAsChannelOwnershipType:]
  -[SharedChannelCreateRequest authCredential]
  -[SharedChannelCreateRequest setAuthCredential:]


SKAPresenceSubscriptionAssertion : NSObject
 @property  NSObject<OS_os_activity> *osActivity
 @property  NSString *subscriptionIdentifier

  // class methods
  +[SKAPresenceSubscriptionAssertion logger]

  // instance methods
  -[SKAPresenceSubscriptionAssertion subscriptionIdentifier]
  -[SKAPresenceSubscriptionAssertion dealloc]
  -[SKAPresenceSubscriptionAssertion .cxx_destruct]
  -[SKAPresenceSubscriptionAssertion isEqual:]
  -[SKAPresenceSubscriptionAssertion osActivity]
  -[SKAPresenceSubscriptionAssertion initWithSubscriptionIdentifier:]
  -[SKAPresenceSubscriptionAssertion isEqualToPresenceSubscription:]


DecryptedParticipantPayload : PBCodable <NSCopying>
 @property  BOOL hasTokenUri
 @property  NSString *tokenUri
 @property  BOOL hasPresenceIdentifier
 @property  NSString *presenceIdentifier
 @property  BOOL hasChannelIdentifier
 @property  NSString *channelIdentifier
 @property  BOOL hasTimestamp
 @property  unsigned long timestamp

  // instance methods
  -[DecryptedParticipantPayload setTimestamp:]
  -[DecryptedParticipantPayload copyTo:]
  -[DecryptedParticipantPayload .cxx_destruct]
  -[DecryptedParticipantPayload mergeFrom:]
  -[DecryptedParticipantPayload setHasTimestamp:]
  -[DecryptedParticipantPayload dictionaryRepresentation]
  -[DecryptedParticipantPayload hasTimestamp]
  -[DecryptedParticipantPayload copyWithZone:]
  -[DecryptedParticipantPayload timestamp]
  -[DecryptedParticipantPayload readFrom:]
  -[DecryptedParticipantPayload writeTo:]
  -[DecryptedParticipantPayload isEqual:]
  -[DecryptedParticipantPayload channelIdentifier]
  -[DecryptedParticipantPayload setChannelIdentifier:]
  -[DecryptedParticipantPayload presenceIdentifier]
  -[DecryptedParticipantPayload hasTokenUri]
  -[DecryptedParticipantPayload hasPresenceIdentifier]
  -[DecryptedParticipantPayload hasChannelIdentifier]
  -[DecryptedParticipantPayload tokenUri]
  -[DecryptedParticipantPayload setTokenUri:]
  -[DecryptedParticipantPayload setPresenceIdentifier:]


SKAStatusPublishingServiceClientConnection : NSObject
 @property  NSXPCConnection *xpcConnection
 @property  <SKAStatusPublishingServiceClientConnectionLifecycleDelegate> *connectionLifecycleDelegate
 @property  int processIdentifier

  // class methods
  +[SKAStatusPublishingServiceClientConnection logger]
  +[SKAStatusPublishingServiceClientConnection clientIsEntitledForAtLeastOnePublishingServiceType:]
  +[SKAStatusPublishingServiceClientConnection _connection:isEntitledForPublishingWithStatusTypeIdentifier:]

  // instance methods
  -[SKAStatusPublishingServiceClientConnection xpcConnection]
  -[SKAStatusPublishingServiceClientConnection dealloc]
  -[SKAStatusPublishingServiceClientConnection .cxx_destruct]
  -[SKAStatusPublishingServiceClientConnection setXpcConnection:]
  -[SKAStatusPublishingServiceClientConnection processIdentifier]
  -[SKAStatusPublishingServiceClientConnection initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:]
  -[SKAStatusPublishingServiceClientConnection asynchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusPublishingServiceClientConnection synchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusPublishingServiceClientConnection clientIsEntitledForPublishingWithStatusTypeIdentifier:]
  -[SKAStatusPublishingServiceClientConnection connectionLifecycleDelegate]
  -[SKAStatusPublishingServiceClientConnection setConnectionLifecycleDelegate:]


ChannelActivityPollingResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasUuid
 @property  NSData *uuid
 @property  BOOL hasServerTimestampSeconds
 @property  unsigned long serverTimestampSeconds
 @property  BOOL hasVersion
 @property  unsigned long version
 @property  NSMutableArray *participantPayloads
 @property  BOOL hasResponseMessageIndex
 @property  unsigned int responseMessageIndex
 @property  BOOL hasTotalResponseMessages
 @property  unsigned int totalResponseMessages

  // class methods
  +[ChannelActivityPollingResponse participantPayloadType]

  // instance methods
  -[ChannelActivityPollingResponse copyTo:]
  -[ChannelActivityPollingResponse setHasStatus:]
  -[ChannelActivityPollingResponse hasStatus]
  -[ChannelActivityPollingResponse status]
  -[ChannelActivityPollingResponse setStatus:]
  -[ChannelActivityPollingResponse uuid]
  -[ChannelActivityPollingResponse statusAsString:]
  -[ChannelActivityPollingResponse hasUuid]
  -[ChannelActivityPollingResponse .cxx_destruct]
  -[ChannelActivityPollingResponse setUuid:]
  -[ChannelActivityPollingResponse mergeFrom:]
  -[ChannelActivityPollingResponse hasVersion]
  -[ChannelActivityPollingResponse StringAsStatus:]
  -[ChannelActivityPollingResponse version]
  -[ChannelActivityPollingResponse dictionaryRepresentation]
  -[ChannelActivityPollingResponse copyWithZone:]
  -[ChannelActivityPollingResponse setHasVersion:]
  -[ChannelActivityPollingResponse readFrom:]
  -[ChannelActivityPollingResponse setVersion:]
  -[ChannelActivityPollingResponse writeTo:]
  -[ChannelActivityPollingResponse isEqual:]
  -[ChannelActivityPollingResponse setServerTimestampSeconds:]
  -[ChannelActivityPollingResponse setHasServerTimestampSeconds:]
  -[ChannelActivityPollingResponse hasServerTimestampSeconds]
  -[ChannelActivityPollingResponse clearParticipantPayloads]
  -[ChannelActivityPollingResponse addParticipantPayload:]
  -[ChannelActivityPollingResponse participantPayloadsCount]
  -[ChannelActivityPollingResponse participantPayloadAtIndex:]
  -[ChannelActivityPollingResponse setResponseMessageIndex:]
  -[ChannelActivityPollingResponse setHasResponseMessageIndex:]
  -[ChannelActivityPollingResponse hasResponseMessageIndex]
  -[ChannelActivityPollingResponse setTotalResponseMessages:]
  -[ChannelActivityPollingResponse setHasTotalResponseMessages:]
  -[ChannelActivityPollingResponse hasTotalResponseMessages]
  -[ChannelActivityPollingResponse serverTimestampSeconds]
  -[ChannelActivityPollingResponse participantPayloads]
  -[ChannelActivityPollingResponse setParticipantPayloads:]
  -[ChannelActivityPollingResponse responseMessageIndex]
  -[ChannelActivityPollingResponse totalResponseMessages]


SKAStatusPublishingManager : NSObject <SKAStatusPublishingManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  <SKAAccountProviding> *accountProvider
 @property  <SKAInvitationManaging> *invitationManager
 @property  NSObject<OS_dispatch_queue> *internalWorkQueue
 @property  BOOL pendingRequestScheduled
 @property  BOOL clientIsRateLimited
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusPublishingManager logger]
  +[SKAStatusPublishingManager _errorForDuplicateStatusPublishRequestWithIdentifier:]
  +[SKAStatusPublishingManager _errorForStatusPublishRequestWithIdentifier:requestedStatusCreationDate:isOlderThanExistingStatus:existingStatusCreationDate:]
  +[SKAStatusPublishingManager _errorForRateLimit]
  +[SKAStatusPublishingManager _noPersonalChannelErrorForStatusTypeIdentifier:]

  // instance methods
  -[SKAStatusPublishingManager databaseManager]
  -[SKAStatusPublishingManager _shouldRollChannelForError:]
  -[SKAStatusPublishingManager _shouldClientRateLimit]
  -[SKAStatusPublishingManager _markPublishAttempt]
  -[SKAStatusPublishingManager internalWorkQueue]
  -[SKAStatusPublishingManager setClientIsRateLimited:]
  -[SKAStatusPublishingManager invitationManager]
  -[SKAStatusPublishingManager _rapidPublishesTimescale]
  -[SKAStatusPublishingManager encryptionManager]
  -[SKAStatusPublishingManager _pendingDelayTime]
  -[SKAStatusPublishingManager _shouldAbandonRequestForError:]
  -[SKAStatusPublishingManager _maxRetryCount]
  -[SKAStatusPublishingManager .cxx_destruct]
  -[SKAStatusPublishingManager _publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:retryCount:completion:]
  -[SKAStatusPublishingManager accountProvider]
  -[SKAStatusPublishingManager _removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:databaseContext:]
  -[SKAStatusPublishingManager _shouldReauthForError:]
  -[SKAStatusPublishingManager _removePendingPublishRequestWithUniqueIdentifier:databaseContext:]
  -[SKAStatusPublishingManager removePendingPublishRequestsForStatusTypeIdentifier:olderThanRequest:]
  -[SKAStatusPublishingManager clientIsRateLimited]
  -[SKAStatusPublishingManager publishStatusRequest:statusTypeIdentifier:afterTime:isPendingPublish:completion:]
  -[SKAStatusPublishingManager pendingRequestScheduled]
  -[SKAStatusPublishingManager setAccountProvider:]
  -[SKAStatusPublishingManager _rateLimitDelayTime]
  -[SKAStatusPublishingManager channelManager]
  -[SKAStatusPublishingManager setChannelManager:]
  -[SKAStatusPublishingManager setInternalWorkQueue:]
  -[SKAStatusPublishingManager _maxRapidPublishes]
  -[SKAStatusPublishingManager publishPendingRequestsWithDelay:]
  -[SKAStatusPublishingManager setEncryptionManager:]
  -[SKAStatusPublishingManager _shouldAllowPublishForPublishRequest:onChannel:error:]
  -[SKAStatusPublishingManager ensurePendingPublishRequestExistsWithPublishRequest:forStatusTypeIdentifier:databaseContext:]
  -[SKAStatusPublishingManager initWithDatabaseManager:channelManager:accountProvider:encryptionManager:invitationManager:]
  -[SKAStatusPublishingManager findOrCreatePersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAStatusPublishingManager setDatabaseManager:]
  -[SKAStatusPublishingManager createPersonalChannelForStatusTypeIdentifier:databaseContext:completion:]
  -[SKAStatusPublishingManager setInvitationManager:]
  -[SKAStatusPublishingManager _shouldRetryWithDelayForError:]
  -[SKAStatusPublishingManager publishPendingRequestForReason:]
  -[SKAStatusPublishingManager setPendingRequestScheduled:]


SKADatabaseChannel : NSObject
 @property  MPStatusKitOutgoingRatchet *currentOutgoingRatchet
 @property  NSData *channelToken
 @property  NSString *identifier
 @property  BOOL personal
 @property  BOOL decomissioned
 @property  NSData *currentOutgoingRatchetState
 @property  NSData *dateChannelCreated
 @property  NSString *statusType
 @property  long long channelType
 @property  NSString *presenceIdentifier
 @property  NSArray *invitedUsers
 @property  NSData *presenceServerKey
 @property  NSData *presencePeerKey
 @property  NSData *presenceMembershipKey

  // class methods
  +[SKADatabaseChannel logger]

  // instance methods
  -[SKADatabaseChannel identifier]
  -[SKADatabaseChannel .cxx_destruct]
  -[SKADatabaseChannel channelType]
  -[SKADatabaseChannel statusType]
  -[SKADatabaseChannel isPersonal]
  -[SKADatabaseChannel presenceIdentifier]
  -[SKADatabaseChannel initWithChannelToken:channelType:identifier:personal:decomissioned:currentOutgoingRatchetState:dateCreated:statusType:presenceIdentifier:invitedUsers:presenceServerKey:presencePeerKey:presenceMembershipKey:]
  -[SKADatabaseChannel channelToken]
  -[SKADatabaseChannel isDecomissioned]
  -[SKADatabaseChannel currentOutgoingRatchetState]
  -[SKADatabaseChannel dateChannelCreated]
  -[SKADatabaseChannel setDateChannelCreated:]
  -[SKADatabaseChannel invitedUsers]
  -[SKADatabaseChannel presenceServerKey]
  -[SKADatabaseChannel presencePeerKey]
  -[SKADatabaseChannel presenceMembershipKey]
  -[SKADatabaseChannel currentOutgoingRatchet]
  -[SKADatabaseChannel initWithCoreDataChannels:]


SKAMessagingProvider : NSObject <IDSServiceDelegate, SKAMessagingProviding>
 @property  IDSService *service
 @property  <SKAPushManaging> *pushManager
 @property  NSString *serviceIdentifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription
 @property  <SKAMessagingProvidingDelegate> *delegate

  // class methods
  +[SKAMessagingProvider logger]
  +[SKAMessagingProvider _noValidIDSDetintationError]

  // instance methods
  -[SKAMessagingProvider setServiceIdentifier:]
  -[SKAMessagingProvider serviceIdentifier]
  -[SKAMessagingProvider verifySignedPayload:matchesPayload:fromTokenURI:completion:]
  -[SKAMessagingProvider setDelegate:]
  -[SKAMessagingProvider deviceToken]
  -[SKAMessagingProvider isHandleMessageable:completion:]
  -[SKAMessagingProvider service:didHintCheckingTransportLogWithReason:]
  -[SKAMessagingProvider sendMessage:toHandles:fromHandle:limitToPresenceCapable:error:]
  -[SKAMessagingProvider delegate]
  -[SKAMessagingProvider setService:]
  -[SKAMessagingProvider pushManager]
  -[SKAMessagingProvider .cxx_destruct]
  -[SKAMessagingProvider sendMessage:toHandle:fromHandle:limitToPresenceCapable:error:]
  -[SKAMessagingProvider service]
  -[SKAMessagingProvider handleForTokenURI:]
  -[SKAMessagingProvider service:account:incomingMessage:fromID:context:]
  -[SKAMessagingProvider isHandleAvailableToMessageFrom:]
  -[SKAMessagingProvider initWithDelegate:serviceIdentifier:pushManager:queue:]
  -[SKAMessagingProvider _keysharingIsDisabledByServer]
  -[SKAMessagingProvider signPayload:completion:]
  -[SKAMessagingProvider isHandleMessageableForPresence:completion:]
  -[SKAMessagingProvider setPushManager:]
  -[SKAMessagingProvider deviceTokenForTokenURI:]
  -[SKAMessagingProvider tokenURI]
  -[SKAMessagingProvider resolveSenderHandleWithPreferredSenderHandle:]


SKAPresenceMembershipKey : NSObject
 @property  ^{__SecKey={__CFRuntimeBase=QAQ}^{__SecKeyDescriptor}^v} privateKey
 @property  NSData *privateKeyMaterial
 @property  NSData *publicKeyMaterial

  // class methods
  +[SKAPresenceMembershipKey logger]

  // instance methods
  -[SKAPresenceMembershipKey privateKey]
  -[SKAPresenceMembershipKey setPrivateKey:]
  -[SKAPresenceMembershipKey initWithNewKeyMaterial]
  -[SKAPresenceMembershipKey initWithPrivateKeyMaterial:]
  -[SKAPresenceMembershipKey signPayload:]
  -[SKAPresenceMembershipKey publicKeyMaterial]
  -[SKAPresenceMembershipKey privateKeyMaterial]
  -[SKAPresenceMembershipKey _generateKey]
  -[SKAPresenceMembershipKey _generateKeyFromKeyData:]


SKAStatusPublishingServiceClient : NSObject <SKStatusPublishingDaemonProtocol, SKAStatusPublishingServiceClientConnectionLifecycleDelegate>
 @property  SKAStatusPublishingServiceClientConnection *clientConnection
 @property  <SKAStatusPublishingServiceClientDelegate> *delegate
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKADatabaseProviding> *databaseProvider
 @property  <SKAMessagingProviding> *messagingProvider
 @property  SKAInvitationManager *invitationManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAStatusPublishingManaging> *publishingManager
 @property  BOOL accountIsStatusKitCapable
 @property  BOOL accountCheckCompleted
 @property  NSObject<OS_dispatch_queue> *queue
 @property  NSString *statusTypeIdenfifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusPublishingServiceClient logger]
  +[SKAStatusPublishingServiceClient _noPersonalChannelErrorForStatusTypeIdentifier:]
  +[SKAStatusPublishingServiceClient _missingEntitlmentErrorForStatusTypeIdentifier:]
  +[SKAStatusPublishingServiceClient _noUsersToShareWithError]
  +[SKAStatusPublishingServiceClient _accountNotCapableError]
  +[SKAStatusPublishingServiceClient _unableToResolveSenderHandleError]
  +[SKAStatusPublishingServiceClient _dateCreatedDriftError]

  // instance methods
  -[SKAStatusPublishingServiceClient databaseManager]
  -[SKAStatusPublishingServiceClient clientConnection]
  -[SKAStatusPublishingServiceClient setDatabaseProvider:]
  -[SKAStatusPublishingServiceClient setDelegate:]
  -[SKAStatusPublishingServiceClient fetchHandleInvitability:fromHandle:forStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient setClientConnection:]
  -[SKAStatusPublishingServiceClient invitationManager]
  -[SKAStatusPublishingServiceClient delegate]
  -[SKAStatusPublishingServiceClient publishingManager]
  -[SKAStatusPublishingServiceClient setPublishingManager:]
  -[SKAStatusPublishingServiceClient .cxx_destruct]
  -[SKAStatusPublishingServiceClient messagingProvider]
  -[SKAStatusPublishingServiceClient setQueue:]
  -[SKAStatusPublishingServiceClient channelManager]
  -[SKAStatusPublishingServiceClient setChannelManager:]
  -[SKAStatusPublishingServiceClient setMessagingProvider:]
  -[SKAStatusPublishingServiceClient queue]
  -[SKAStatusPublishingServiceClient setDatabaseManager:]
  -[SKAStatusPublishingServiceClient setInvitationManager:]
  -[SKAStatusPublishingServiceClient databaseProvider]
  -[SKAStatusPublishingServiceClient publishStatusRequest:statusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient invitedHandlesForStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient isHandleInvited:fromSenderHandle:forStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient isHandleInviteable:fromHandle:forStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient inviteHandles:fromSenderHandle:withInvitationPayload:statusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient removeInvitedHandles:statusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient removeAllInvitedHandlesFromPersonalChannelWithStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient registerForDelegateCallbacksWithStatusTypeIdentifier:completion:]
  -[SKAStatusPublishingServiceClient publishingServiceClientConnectionWasInvalidated:]
  -[SKAStatusPublishingServiceClient publishingServiceClientConnectionWasInterrupted:]
  -[SKAStatusPublishingServiceClient initWithXPCConnection:queue:delegate:databaseManager:invitationManager:publishingManager:channelManager:]
  -[SKAStatusPublishingServiceClient accountIsStatusKitCapableWithCompletion:]
  -[SKAStatusPublishingServiceClient _serverBagNumberForKey:]
  -[SKAStatusPublishingServiceClient _serverBagTimeIntervalForKey:withDefaultValue:]
  -[SKAStatusPublishingServiceClient _scheduledPublishMaxDelayTime]
  -[SKAStatusPublishingServiceClient _unscheduledPublishMaxDelayTime]
  -[SKAStatusPublishingServiceClient _randomScheduledPublishDelay]
  -[SKAStatusPublishingServiceClient _randomUnscheduledPublishDelay]
  -[SKAStatusPublishingServiceClient _secondaryDeviceRepublishMaxDelayTime]
  -[SKAStatusPublishingServiceClient _secondaryDeviceRepublishMinDelayTime]
  -[SKAStatusPublishingServiceClient _randomSecondaryDeviceRepublishDelay]
  -[SKAStatusPublishingServiceClient _delayForStatusPublishRequest:]
  -[SKAStatusPublishingServiceClient statusTypeIdenfifier]
  -[SKAStatusPublishingServiceClient accountIsStatusKitCapable]
  -[SKAStatusPublishingServiceClient setAccountIsStatusKitCapable:]
  -[SKAStatusPublishingServiceClient accountCheckCompleted]
  -[SKAStatusPublishingServiceClient setAccountCheckCompleted:]


SKAStatusSubscriptionServiceClient : NSObject <SKStatusSubscriptionDaemonProtocol, SKAClientConnectionRepresentable, SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate>
 @property  SKAStatusSubscriptionServiceClientConnection *clientConnection
 @property  <SKAStatusSubscriptionServiceClientDelegate> *delegate
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAStatusSubscriptionManaging> *subscriptionManager
 @property  BOOL accountCheckCompleted
 @property  BOOL accountIsStatusKitCapable
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  NSObject<OS_dispatch_queue> *queue
 @property  BOOL trafficModeEnabled
 @property  NSString *statusTypeIdenfifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusSubscriptionServiceClient logger]
  +[SKAStatusSubscriptionServiceClient _missingEntitlmentErrorForStatusTypeIdentifier:]
  +[SKAStatusSubscriptionServiceClient _accountNotCapableError]
  +[SKAStatusSubscriptionServiceClient _genericMissingSubscriptionEntitlmentError]
  +[SKAStatusSubscriptionServiceClient _inTrafficError]
  +[SKAStatusSubscriptionServiceClient _subscriptionIdentifierNotFoundError:]

  // instance methods
  -[SKAStatusSubscriptionServiceClient databaseManager]
  -[SKAStatusSubscriptionServiceClient clientConnection]
  -[SKAStatusSubscriptionServiceClient releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient setDelegate:]
  -[SKAStatusSubscriptionServiceClient setClientConnection:]
  -[SKAStatusSubscriptionServiceClient delegate]
  -[SKAStatusSubscriptionServiceClient setTrafficModeEnabled:]
  -[SKAStatusSubscriptionServiceClient encryptionManager]
  -[SKAStatusSubscriptionServiceClient .cxx_destruct]
  -[SKAStatusSubscriptionServiceClient subscriptionManager]
  -[SKAStatusSubscriptionServiceClient setQueue:]
  -[SKAStatusSubscriptionServiceClient queue]
  -[SKAStatusSubscriptionServiceClient setEncryptionManager:]
  -[SKAStatusSubscriptionServiceClient setSubscriptionManager:]
  -[SKAStatusSubscriptionServiceClient trafficModeEnabled]
  -[SKAStatusSubscriptionServiceClient setDatabaseManager:]
  -[SKAStatusSubscriptionServiceClient retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient registerForDelegateCallbacksWithStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient subscriptionMetadataForHandle:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient allSubscriptionMetadatasForStatusTypeIdentifier:includingPersonalSubscription:completion:]
  -[SKAStatusSubscriptionServiceClient allSubscriptionMetadatasWithActiveAssertionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient allSubscriptionMetadatasWithActiveSubscriptionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient allStatusSubscriptionsWithPersistentSubscriptionAssertionForApplicationIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient subscriptionMetadataForPersonalSubscriptionWithStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient deleteSubscriptionWithIdentifier:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient subscriptionValidationTokensForHandle:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient validatePersonalStatusSubscriptionMatchesSubscriptionValidationTokens:fromSender:statusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionServiceClient accountIsStatusKitCapableWithCompletion:]
  -[SKAStatusSubscriptionServiceClient statusTypeIdenfifier]
  -[SKAStatusSubscriptionServiceClient accountIsStatusKitCapable]
  -[SKAStatusSubscriptionServiceClient setAccountIsStatusKitCapable:]
  -[SKAStatusSubscriptionServiceClient accountCheckCompleted]
  -[SKAStatusSubscriptionServiceClient setAccountCheckCompleted:]
  -[SKAStatusSubscriptionServiceClient subscriptionServiceClientConnectionWasInvalidated:]
  -[SKAStatusSubscriptionServiceClient subscriptionServiceClientConnectionWasInterrupted:]
  -[SKAStatusSubscriptionServiceClient initWithXPCConnection:queue:delegate:databaseManager:subscriptionManager:encryptionManager:inTrafficMode:]
  -[SKAStatusSubscriptionServiceClient handleRemoteDatabaseChangeForChannels:]
  -[SKAStatusSubscriptionServiceClient handleReceivedStatusUpdate:onChannel:]
  -[SKAStatusSubscriptionServiceClient handleReceivedInvitationForChannel:]
  -[SKAStatusSubscriptionServiceClient _subscriptionMetadataForChannel:]
  -[SKAStatusSubscriptionServiceClient _handlesAssociatedWithChannel:]
  -[SKAStatusSubscriptionServiceClient _currentStatusForChannel:]
  -[SKAStatusSubscriptionServiceClient channelMatchesClientStatusTypeIdentifier:]
  -[SKAStatusSubscriptionServiceClient validatePersonalChannel:matchesSubscriptionValidationToken:fromSender:]
  -[SKAStatusSubscriptionServiceClient validatePersonalChannel:matchesEncryptionValidationToken:fromSender:]
  -[SKAStatusSubscriptionServiceClient _validateChannelIsKnownForSubscriptionIdentifier:statusTypeIdentifier:databaseContext:]


SKAPresenceManager : NSObject <SKAPresenceManaging>
 @property  NSMapTable *activePresenceAssertionsByClient
 @property  NSMapTable *activeParticipantsByChannel
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAAccountProviding> *accountProvider
 @property  <SKAMessagingProviding> *messagingProvider
 @property  <SKAPresenceManagingDelegate> *delegate
 @property  NSObject<OS_dispatch_queue> *internalWorkQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAPresenceManager logger]
  +[SKAPresenceManager _noExistingAssertionError]
  +[SKAPresenceManager _noExistingChannelError]
  +[SKAPresenceManager _keyGenerationError]
  +[SKAPresenceManager _payloadGenerationError]

  // instance methods
  -[SKAPresenceManager databaseManager]
  -[SKAPresenceManager internalWorkQueue]
  -[SKAPresenceManager _recalculateActivityTracking]
  -[SKAPresenceManager _presencePayloadForChannel:timestamp:completion:]
  -[SKAPresenceManager _setCheckpointForChannel:checkpoint:]
  -[SKAPresenceManager setDelegate:]
  -[SKAPresenceManager activePresenceAssertionsByClient]
  -[SKAPresenceManager _markReassert]
  -[SKAPresenceManager createPresenceChannelForPresenceIdentifier:databaseContext:completion:]
  -[SKAPresenceManager delegate]
  -[SKAPresenceManager _handleBulkUpdateParticipantPayloads:forChannel:]
  -[SKAPresenceManager activeParticipantsByChannel]
  -[SKAPresenceManager releaseAllPresenceAssertionsAssociatedWithClient:completion:]
  -[SKAPresenceManager _removePresentDeviceForChannel:presentDevice:]
  -[SKAPresenceManager setActivePresenceAssertionsByClient:]
  -[SKAPresenceManager _clearPresentDevicesForChannel:]
  -[SKAPresenceManager .cxx_destruct]
  -[SKAPresenceManager retainPresenceAssertionForPresenceIdentifier:client:completion:]
  -[SKAPresenceManager presentDevicesForPresenceIdentifier:completion:]
  -[SKAPresenceManager setActiveParticipantsByChannel:]
  -[SKAPresenceManager channelReceivedIncomingPayloadUpdate:channel:]
  -[SKAPresenceManager accountProvider]
  -[SKAPresenceManager findOrCreatePresenceChannelForPresenceIdentifier:databaseContext:completion:]
  -[SKAPresenceManager _shouldReauthForError:]
  -[SKAPresenceManager messagingProvider]
  -[SKAPresenceManager _addPresentDeviceForChannel:presentDevice:]
  -[SKAPresenceManager _shouldReassert]
  -[SKAPresenceManager _mostRecentPublishTimeForTokenURI:onChannel:]
  -[SKAPresenceManager _activePresentDevicesForChannel:]
  -[SKAPresenceManager _sendPresenceAssertionMessageForChannel:isRefresh:completion:]
  -[SKAPresenceManager initWithDatabaseManager:channelManager:accountProvider:messagingProvider:delegate:]
  -[SKAPresenceManager _activePresenceAssertionsForClient:]
  -[SKAPresenceManager setAccountProvider:]
  -[SKAPresenceManager channelManager]
  -[SKAPresenceManager _presentDevicesChangedForChannel:]
  -[SKAPresenceManager setChannelManager:]
  -[SKAPresenceManager setInternalWorkQueue:]
  -[SKAPresenceManager setMessagingProvider:]
  -[SKAPresenceManager _sortAndDedupePresenceIdentifiers:]
  -[SKAPresenceManager _activePresenceAssertionExistsForPresenceIdentifier:]
  -[SKAPresenceManager setDatabaseManager:]
  -[SKAPresenceManager _currentCheckpointForChannel:]
  -[SKAPresenceManager _sendPollingMessageForChannel:completion:]
  -[SKAPresenceManager _reassertResetTimeSeconds]
  -[SKAPresenceManager _removePresenceAssertionForClient:presenceIdentifier:]
  -[SKAPresenceManager _activePresenceAssertionsExist]
  -[SKAPresenceManager _presentDeviceFromPayload:onChannel:]
  -[SKAPresenceManager releasePresenceAssertionForPresenceIdentifier:client:completion:]
  -[SKAPresenceManager findPresenceChannelForPresenceIdentifier:databaseContext:completion:]
  -[SKAPresenceManager _deviceIdentifierForToken:]
  -[SKAPresenceManager _addPresenceAssertionForClient:presenceIdentifier:]
  -[SKAPresenceManager _sendPresenceDeactivationMessageForChannel:completion:]


SKAStatusReceivingManager : NSObject <SKAStatusReceivingManaging>
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  <SKAStatusReceivingManagingDelegate> *delegate
 @property  NSObject<OS_dispatch_queue> *backgroundCleanupQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusReceivingManager logger]

  // instance methods
  -[SKAStatusReceivingManager handleIncomingStatusData:onChannelIdentifier:dateReceived:dateExpired:serverTime:]
  -[SKAStatusReceivingManager databaseManager]
  -[SKAStatusReceivingManager setDelegate:]
  -[SKAStatusReceivingManager delegate]
  -[SKAStatusReceivingManager encryptionManager]
  -[SKAStatusReceivingManager .cxx_destruct]
  -[SKAStatusReceivingManager initWithDatabaseManager:encryptionManager:delegate:]
  -[SKAStatusReceivingManager setEncryptionManager:]
  -[SKAStatusReceivingManager setDatabaseManager:]
  -[SKAStatusReceivingManager backgroundCleanupQueue]
  -[SKAStatusReceivingManager setBackgroundCleanupQueue:]


SKAChannelManager : NSObject <SKAPushManagingDelegate, SKAChannelManaging>
 @property  <SKAPushManaging> *pushManager
 @property  <SKAAccountProviding> *accountProvider
 @property  <SKAChannelManagingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAChannelManager logger]
  +[SKAChannelManager _jwtTokenNotFoundError]
  +[SKAChannelManager _serverResponseError]

  // instance methods
  -[SKAChannelManager createPresenceChannelWithMembershipKey:serverKey:completion:]
  -[SKAChannelManager setDelegate:]
  -[SKAChannelManager delegate]
  -[SKAChannelManager createChannelWithCompletion:]
  -[SKAChannelManager pushManager]
  -[SKAChannelManager .cxx_destruct]
  -[SKAChannelManager enableActivityTracking]
  -[SKAChannelManager activePresenceChannelSubscriptionsWithCompletion:]
  -[SKAChannelManager accountProvider]
  -[SKAChannelManager disableActivityTracking]
  -[SKAChannelManager activeStatusChannelSubscriptionsWithCompletion:]
  -[SKAChannelManager _createPayloadDataFromData:]
  -[SKAChannelManager subscribeToStatusChannels:]
  -[SKAChannelManager initWithPushManager:accountProvider:delegate:]
  -[SKAChannelManager publishData:onChannel:withChannelToken:publishInitiateTime:isPendingPublish:isScheduledPublish:retryCount:completion:]
  -[SKAChannelManager _getNonce]
  -[SKAChannelManager setAccountProvider:]
  -[SKAChannelManager serverTime]
  -[SKAChannelManager pushManager:didReceiveData:onChannel:dateReceived:dateExpired:]
  -[SKAChannelManager _getPresenceJWTToken]
  -[SKAChannelManager _getStatusJWTToken]
  -[SKAChannelManager pollActiveParticipantsForChannel:membershipKey:serverKey:withChannelToken:completion:]
  -[SKAChannelManager unsubscribeFromStatusChannels:]
  -[SKAChannelManager subscribeToPresenceChannels:]
  -[SKAChannelManager pushManager:failedToSubscribeToChannel:withError:]
  -[SKAChannelManager setPushManager:]
  -[SKAChannelManager assertPresence:onChannel:membershipKey:serverKey:timestamp:withChannelToken:isRefresh:completion:]
  -[SKAChannelManager releasePresenceOnChannel:membershipKey:serverKey:timestamp:withChannelToken:completion:]
  -[SKAChannelManager unsubscribeFromPresenceChannels:]


SharedChannelPublishResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasRetryIntervalSeconds
 @property  unsigned int retryIntervalSeconds

  // instance methods
  -[SharedChannelPublishResponse copyTo:]
  -[SharedChannelPublishResponse setHasStatus:]
  -[SharedChannelPublishResponse hasStatus]
  -[SharedChannelPublishResponse status]
  -[SharedChannelPublishResponse setStatus:]
  -[SharedChannelPublishResponse statusAsString:]
  -[SharedChannelPublishResponse mergeFrom:]
  -[SharedChannelPublishResponse StringAsStatus:]
  -[SharedChannelPublishResponse dictionaryRepresentation]
  -[SharedChannelPublishResponse copyWithZone:]
  -[SharedChannelPublishResponse readFrom:]
  -[SharedChannelPublishResponse writeTo:]
  -[SharedChannelPublishResponse isEqual:]
  -[SharedChannelPublishResponse setRetryIntervalSeconds:]
  -[SharedChannelPublishResponse retryIntervalSeconds]
  -[SharedChannelPublishResponse setHasRetryIntervalSeconds:]
  -[SharedChannelPublishResponse hasRetryIntervalSeconds]


SKADatabaseReceivedInvitation : NSObject
 @property  SKHandle *invitedSKHandle
 @property  SKHandle *senderSKHandle
 @property  MPStatusKitIncomingRatchet *incomingRatchet
 @property  SKInvitationPayload *skInvitationPayload
 @property  long long invitationType
 @property  NSString *senderHandle
 @property  NSString *invitedHandle
 @property  NSString *statusTypeIdentifier
 @property  NSString *presenceIdentifier
 @property  NSData *channelToken
 @property  NSData *peerKey
 @property  NSData *serverKey
 @property  NSString *invitationIdentifier
 @property  NSDate *dateInvitationCreated
 @property  NSData *incomingRatchetState
 @property  NSData *invitationPayload

  // class methods
  +[SKADatabaseReceivedInvitation logger]

  // instance methods
  -[SKADatabaseReceivedInvitation .cxx_destruct]
  -[SKADatabaseReceivedInvitation statusTypeIdentifier]
  -[SKADatabaseReceivedInvitation senderHandle]
  -[SKADatabaseReceivedInvitation peerKey]
  -[SKADatabaseReceivedInvitation invitationIdentifier]
  -[SKADatabaseReceivedInvitation invitationType]
  -[SKADatabaseReceivedInvitation invitationPayload]
  -[SKADatabaseReceivedInvitation presenceIdentifier]
  -[SKADatabaseReceivedInvitation channelToken]
  -[SKADatabaseReceivedInvitation initWithCoreDataReceivedInvitation:]
  -[SKADatabaseReceivedInvitation initWithInvitationIdentifier:senderHandle:invitedHandle:statusTypeIdentifier:dateInvitationCreated:incomingRatchetState:presenceIdentifier:channelToken:serverKey:peerKey:invitationPayload:]
  -[SKADatabaseReceivedInvitation invitedHandle]
  -[SKADatabaseReceivedInvitation serverKey]
  -[SKADatabaseReceivedInvitation dateInvitationCreated]
  -[SKADatabaseReceivedInvitation incomingRatchetState]
  -[SKADatabaseReceivedInvitation invitedSKHandle]
  -[SKADatabaseReceivedInvitation senderSKHandle]
  -[SKADatabaseReceivedInvitation incomingRatchet]
  -[SKADatabaseReceivedInvitation skInvitationPayload]


SKADatabaseTransientSubscriptionHistory : NSObject
 @property  NSString *channelIdentifier
 @property  NSDate *lastSubscriptionDate

  // instance methods
  -[SKADatabaseTransientSubscriptionHistory .cxx_destruct]
  -[SKADatabaseTransientSubscriptionHistory channelIdentifier]
  -[SKADatabaseTransientSubscriptionHistory initWithCoreDataTransientSubscriptionHistory:]
  -[SKADatabaseTransientSubscriptionHistory initWithChannelIdentifier:lastSubscriptionDate:]
  -[SKADatabaseTransientSubscriptionHistory lastSubscriptionDate]


SKAPresenceEncryptionKey : NSObject
 @property  NSData *keyData
 @property  NSData *keyMaterial

  // class methods
  +[SKAPresenceEncryptionKey logger]

  // instance methods
  -[SKAPresenceEncryptionKey keyMaterial]
  -[SKAPresenceEncryptionKey keyData]
  -[SKAPresenceEncryptionKey .cxx_destruct]
  -[SKAPresenceEncryptionKey setKeyData:]
  -[SKAPresenceEncryptionKey _randomBytesWithLength:error:]
  -[SKAPresenceEncryptionKey initWithNewKeyMaterial]
  -[SKAPresenceEncryptionKey initWithKeyMaterial:]
  -[SKAPresenceEncryptionKey encryptPayload:]
  -[SKAPresenceEncryptionKey decryptPayload:]
  -[SKAPresenceEncryptionKey _initializeNewKeyMaterial]


SKAAccountProvider : NSObject <SKAAccountProviding>
 @property  NSObject<OS_dispatch_queue> *tokenFetchQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAAccountProvider logger]

  // instance methods
  -[SKAAccountProvider _maxReauthCount]
  -[SKAAccountProvider _markReauthAttempt]
  -[SKAAccountProvider _jwtTokenForPrimaryAccountForIdentifier:withError:]
  -[SKAAccountProvider .cxx_destruct]
  -[SKAAccountProvider _authResetTime]
  -[SKAAccountProvider _shouldAttemptReauth]
  -[SKAAccountProvider _primarySystemiCloudAccountWithError:]
  -[SKAAccountProvider refreshCredentialForPrimaryAccountWithCompletion:]
  -[SKAAccountProvider presenceJwtTokenForPrimaryAccountWithError:]
  -[SKAAccountProvider statusJwtTokenForPrimaryAccountWithError:]
  -[SKAAccountProvider setTokenFetchQueue:]
  -[SKAAccountProvider tokenFetchQueue]
  -[SKAAccountProvider init]


ChannelActivityParticipantPayload : PBCodable <NSCopying>
 @property  BOOL hasEncryptedParticipantPayload
 @property  NSData *encryptedParticipantPayload
 @property  BOOL hasServerUpdateTimestampSeconds
 @property  unsigned long serverUpdateTimestampSeconds

  // instance methods
  -[ChannelActivityParticipantPayload copyTo:]
  -[ChannelActivityParticipantPayload .cxx_destruct]
  -[ChannelActivityParticipantPayload mergeFrom:]
  -[ChannelActivityParticipantPayload dictionaryRepresentation]
  -[ChannelActivityParticipantPayload copyWithZone:]
  -[ChannelActivityParticipantPayload readFrom:]
  -[ChannelActivityParticipantPayload writeTo:]
  -[ChannelActivityParticipantPayload isEqual:]
  -[ChannelActivityParticipantPayload hasEncryptedParticipantPayload]
  -[ChannelActivityParticipantPayload setServerUpdateTimestampSeconds:]
  -[ChannelActivityParticipantPayload setHasServerUpdateTimestampSeconds:]
  -[ChannelActivityParticipantPayload hasServerUpdateTimestampSeconds]
  -[ChannelActivityParticipantPayload encryptedParticipantPayload]
  -[ChannelActivityParticipantPayload setEncryptedParticipantPayload:]
  -[ChannelActivityParticipantPayload serverUpdateTimestampSeconds]


ChannelIdentity : PBCodable <NSCopying>
 @property  BOOL hasChannelTopic
 @property  NSString *channelTopic
 @property  BOOL hasChannelId
 @property  NSData *channelId
 @property  BOOL hasChannelToken
 @property  NSData *channelToken
 @property  BOOL hasChannelOwnershipType
 @property  int channelOwnershipType

  // instance methods
  -[ChannelIdentity copyTo:]
  -[ChannelIdentity .cxx_destruct]
  -[ChannelIdentity mergeFrom:]
  -[ChannelIdentity setChannelTopic:]
  -[ChannelIdentity dictionaryRepresentation]
  -[ChannelIdentity copyWithZone:]
  -[ChannelIdentity channelTopic]
  -[ChannelIdentity readFrom:]
  -[ChannelIdentity writeTo:]
  -[ChannelIdentity isEqual:]
  -[ChannelIdentity channelId]
  -[ChannelIdentity setChannelId:]
  -[ChannelIdentity hasChannelId]
  -[ChannelIdentity hasChannelTopic]
  -[ChannelIdentity channelOwnershipType]
  -[ChannelIdentity setChannelOwnershipType:]
  -[ChannelIdentity setHasChannelOwnershipType:]
  -[ChannelIdentity hasChannelOwnershipType]
  -[ChannelIdentity channelOwnershipTypeAsString:]
  -[ChannelIdentity StringAsChannelOwnershipType:]
  -[ChannelIdentity channelToken]
  -[ChannelIdentity hasChannelToken]
  -[ChannelIdentity setChannelToken:]


SKAPushManager : NSObject <APSConnectionDelegate, SKASystemMonitorListener, SKAPushManaging>
 @property  NSObject<OS_dispatch_queue> *queue
 @property  SKASystemMonitor *systemMonitor
 @property  APSConnection *connection
 @property  FTMessageDelivery *messageDelivery
 @property  BOOL trafficModeEnabled
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription
 @property  <SKAPushManagingDelegate> *delegate

  // class methods
  +[SKAPushManager logger]

  // instance methods
  -[SKAPushManager pushToken]
  -[SKAPushManager connection:didReceiveIncomingMessage:]
  -[SKAPushManager connection:channelSubscriptionsFailedWithFailures:]
  -[SKAPushManager connection:didReceivePublicToken:]
  -[SKAPushManager subscribedPresenceChannelsWithCompletion:]
  -[SKAPushManager _switchFilterToEnabledForTopic:]
  -[SKAPushManager _subscribedChannelsForTopic:WithCompletion:]
  -[SKAPushManager setDelegate:]
  -[SKAPushManager systemMonitor]
  -[SKAPushManager delegate]
  -[SKAPushManager setTrafficModeEnabled:]
  -[SKAPushManager publishStatus:completion:]
  -[SKAPushManager switchPresenceFilterToEnabled]
  -[SKAPushManager _unsubscribeFromChannels:forTopic:]
  -[SKAPushManager setMessageDelivery:]
  -[SKAPushManager switchPresenceFilterToNonwaking]
  -[SKAPushManager .cxx_destruct]
  -[SKAPushManager _sharedChannelsIsDisabledByServer]
  -[SKAPushManager enableActivityTracking]
  -[SKAPushManager connection]
  -[SKAPushManager sendPresenceMessage:completion:]
  -[SKAPushManager disableActivityTracking]
  -[SKAPushManager subscribeToStatusChannels:]
  -[SKAPushManager _initializeAPSConnection]
  -[SKAPushManager subscribedStatusChannelsWithCompletion:]
  -[SKAPushManager createChannelWithProtoData:completion:]
  -[SKAPushManager _pushEnvironment]
  -[SKAPushManager messageDelivery]
  -[SKAPushManager setQueue:]
  -[SKAPushManager serverTime]
  -[SKAPushManager _switchFilterToNonwakingForTopic:]
  -[SKAPushManager setSystemMonitor:]
  -[SKAPushManager switchStatusFilterToNonwaking]
  -[SKAPushManager queue]
  -[SKAPushManager unsubscribeFromStatusChannels:]
  -[SKAPushManager systemDidLeaveFirstDataProtectionLock]
  -[SKAPushManager subscribeToPresenceChannels:]
  -[SKAPushManager trafficModeEnabled]
  -[SKAPushManager _subscribeToChannels:forTopic:]
  -[SKAPushManager unsubscribeFromPresenceChannels:]
  -[SKAPushManager initWithQueue:systemMonitor:inTrafficMode:]
  -[SKAPushManager setConnection:]
  -[SKAPushManager switchStatusFilterToEnabled]


SKADatabaseStatus : NSObject
 @property  NSString *channelIdentifier
 @property  NSDate *dateCreated
 @property  NSDate *datePublished
 @property  NSDate *dateReceived
 @property  NSDate *dateExpired
 @property  NSData *rawData
 @property  NSString *uniqueIdentifier
 @property  BOOL isExpired

  // class methods
  +[SKADatabaseStatus logger]

  // instance methods
  -[SKADatabaseStatus rawData]
  -[SKADatabaseStatus dateCreated]
  -[SKADatabaseStatus .cxx_destruct]
  -[SKADatabaseStatus dateReceived]
  -[SKADatabaseStatus uniqueIdentifier]
  -[SKADatabaseStatus isExpired]
  -[SKADatabaseStatus channelIdentifier]
  -[SKADatabaseStatus datePublished]
  -[SKADatabaseStatus initWithCoreDataStatus:]
  -[SKADatabaseStatus initWithChannelIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:uniqueIdentifier:]
  -[SKADatabaseStatus dateExpired]


SharedChannelCreateResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasRetryIntervalSeconds
 @property  unsigned int retryIntervalSeconds

  // instance methods
  -[SharedChannelCreateResponse copyTo:]
  -[SharedChannelCreateResponse setHasStatus:]
  -[SharedChannelCreateResponse hasStatus]
  -[SharedChannelCreateResponse status]
  -[SharedChannelCreateResponse setStatus:]
  -[SharedChannelCreateResponse statusAsString:]
  -[SharedChannelCreateResponse .cxx_destruct]
  -[SharedChannelCreateResponse mergeFrom:]
  -[SharedChannelCreateResponse StringAsStatus:]
  -[SharedChannelCreateResponse dictionaryRepresentation]
  -[SharedChannelCreateResponse copyWithZone:]
  -[SharedChannelCreateResponse readFrom:]
  -[SharedChannelCreateResponse writeTo:]
  -[SharedChannelCreateResponse isEqual:]
  -[SharedChannelCreateResponse setRetryIntervalSeconds:]
  -[SharedChannelCreateResponse retryIntervalSeconds]
  -[SharedChannelCreateResponse setHasRetryIntervalSeconds:]
  -[SharedChannelCreateResponse hasRetryIntervalSeconds]
  -[SharedChannelCreateResponse hasChannelIdentity]
  -[SharedChannelCreateResponse channelIdentity]
  -[SharedChannelCreateResponse setChannelIdentity:]


ChannelActivityDeactivationRequest : PBRequest <NSCopying>
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasUuid
 @property  NSData *uuid
 @property  BOOL hasClientTimestampSeconds
 @property  unsigned long clientTimestampSeconds

  // instance methods
  -[ChannelActivityDeactivationRequest copyTo:]
  -[ChannelActivityDeactivationRequest uuid]
  -[ChannelActivityDeactivationRequest hasUuid]
  -[ChannelActivityDeactivationRequest .cxx_destruct]
  -[ChannelActivityDeactivationRequest setUuid:]
  -[ChannelActivityDeactivationRequest mergeFrom:]
  -[ChannelActivityDeactivationRequest dictionaryRepresentation]
  -[ChannelActivityDeactivationRequest copyWithZone:]
  -[ChannelActivityDeactivationRequest readFrom:]
  -[ChannelActivityDeactivationRequest writeTo:]
  -[ChannelActivityDeactivationRequest isEqual:]
  -[ChannelActivityDeactivationRequest hasAuthCredential]
  -[ChannelActivityDeactivationRequest authCredential]
  -[ChannelActivityDeactivationRequest setAuthCredential:]
  -[ChannelActivityDeactivationRequest hasChannelIdentity]
  -[ChannelActivityDeactivationRequest channelIdentity]
  -[ChannelActivityDeactivationRequest setChannelIdentity:]
  -[ChannelActivityDeactivationRequest setClientTimestampSeconds:]
  -[ChannelActivityDeactivationRequest setHasClientTimestampSeconds:]
  -[ChannelActivityDeactivationRequest hasClientTimestampSeconds]
  -[ChannelActivityDeactivationRequest clientTimestampSeconds]


SKAStatusSubscriptionManager : NSObject <SKAStatusSubscriptionManaging>
 @property  NSMapTable *activeTransientSubscriptionsByClient
 @property  NSMapTable *activePresenceSubscriptionsByClient
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAPushManaging> *pushManager
 @property  NSObject<OS_dispatch_queue> *internalWorkQueue
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusSubscriptionManager logger]

  // instance methods
  -[SKAStatusSubscriptionManager databaseManager]
  -[SKAStatusSubscriptionManager updateRegisteredSubscriptionsForActiveAssertionsWithCompletion:]
  -[SKAStatusSubscriptionManager setActivePresenceSubscriptionsByClient:]
  -[SKAStatusSubscriptionManager _addTransientSubscriptionAssertionForClient:subscriptionIdentifier:]
  -[SKAStatusSubscriptionManager allStatusSubscriptionIdentifiersWithActiveSubscriptionsWithCompletion:]
  -[SKAStatusSubscriptionManager releasePersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionManager internalWorkQueue]
  -[SKAStatusSubscriptionManager _enforceSubscriptionsHardCapOnSubscriptionIdentifiers:]
  -[SKAStatusSubscriptionManager activeTransientSubscriptionsByClient]
  -[SKAStatusSubscriptionManager releaseAllTransientSubscriptionAssertionsAssociatedWithClient:completion:]
  -[SKAStatusSubscriptionManager _fetchAllActiveSubscriptionAssertionsWithCache]
  -[SKAStatusSubscriptionManager setActiveTransientSubscriptionsByClient:]
  -[SKAStatusSubscriptionManager pushManager]
  -[SKAStatusSubscriptionManager .cxx_destruct]
  -[SKAStatusSubscriptionManager _activeTransientSubscriptionsForClient:]
  -[SKAStatusSubscriptionManager _recentlyReleasedTransientSubscriptionAssertionIdentifiersExcludingSubscriptionIdentifiers:count:databaseContext:]
  -[SKAStatusSubscriptionManager _removeTransientSubscriptionAssertionForClient:subscriptionIdentifier:]
  -[SKAStatusSubscriptionManager releasePresenceSubscriptionAssertionForSubscriptionIdentifier:client:completion:]
  -[SKAStatusSubscriptionManager retainPresenceSubscriptionAssertionForSubscriptionIdentifier:client:completion:]
  -[SKAStatusSubscriptionManager _removePresenceSubscriptionAssertionForClient:subscriptionIdentifier:]
  -[SKAStatusSubscriptionManager _addPresenceSubscriptionAssertionForClient:subscriptionIdentifier:]
  -[SKAStatusSubscriptionManager channelManager]
  -[SKAStatusSubscriptionManager releaseAllPresenceSubscriptionAssertionsAssociatedWithClient:completion:]
  -[SKAStatusSubscriptionManager setChannelManager:]
  -[SKAStatusSubscriptionManager _markCacheSubscriptionDateForChannelIdentifier:]
  -[SKAStatusSubscriptionManager setInternalWorkQueue:]
  -[SKAStatusSubscriptionManager releaseTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:]
  -[SKAStatusSubscriptionManager _activeTransientAssertionsExist]
  -[SKAStatusSubscriptionManager _statusTypeIdentifiersRequiringSelfSubscription]
  -[SKAStatusSubscriptionManager initWithDatabaseManager:channelManager:pushManager:]
  -[SKAStatusSubscriptionManager _filterSubscriptionIdentifierToPresence:]
  -[SKAStatusSubscriptionManager _filterSubscriptionIdentifierToStatus:]
  -[SKAStatusSubscriptionManager _sortAndDedupeSubscriptionIdentifiers:]
  -[SKAStatusSubscriptionManager _subscriptionTTL]
  -[SKAStatusSubscriptionManager retainTransientSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:client:completion:]
  -[SKAStatusSubscriptionManager _fetchAllClientActiveSubscriptionAssertions]
  -[SKAStatusSubscriptionManager setDatabaseManager:]
  -[SKAStatusSubscriptionManager allSubscriptionIdentifiersWithActiveAssertionsForStatusTypeIdentifier:completion:]
  -[SKAStatusSubscriptionManager _hardMaxSubscriptionCount]
  -[SKAStatusSubscriptionManager _allPersonalChannelIdentifiersRequiringSelfSubscriptionWithDatabaseContext:]
  -[SKAStatusSubscriptionManager setPushManager:]
  -[SKAStatusSubscriptionManager retainPersistentSubscriptionAssertionForSubscriptionIdentifier:statusTypeIdentifier:applicationIdentifier:completion:]
  -[SKAStatusSubscriptionManager _activePresenceAssertionsExist]
  -[SKAStatusSubscriptionManager _activePresenceSubscriptionsForClient:]
  -[SKAStatusSubscriptionManager _maxSubscriptionCacheCount]
  -[SKAStatusSubscriptionManager activePresenceSubscriptionsByClient]


SKATransientSubscriptionAssertion : NSObject
 @property  NSObject<OS_os_activity> *osActivity
 @property  NSString *subscriptionIdentifier

  // class methods
  +[SKATransientSubscriptionAssertion logger]

  // instance methods
  -[SKATransientSubscriptionAssertion subscriptionIdentifier]
  -[SKATransientSubscriptionAssertion dealloc]
  -[SKATransientSubscriptionAssertion .cxx_destruct]
  -[SKATransientSubscriptionAssertion isEqual:]
  -[SKATransientSubscriptionAssertion osActivity]
  -[SKATransientSubscriptionAssertion initWithSubscriptionIdentifier:]
  -[SKATransientSubscriptionAssertion isEqualToTransientSubscription:]


AuthCredential : PBCodable <NSCopying>
 @property  BOOL hasSimpleJwt
 @property  NSString *simpleJwt
 @property  BOOL hasSharedOwnershipAuth
 @property  SharedOwnershipAuth *sharedOwnershipAuth
 @property  BOOL hasAuthCredentialOneof
 @property  int authCredentialOneof

  // instance methods
  -[AuthCredential copyTo:]
  -[AuthCredential .cxx_destruct]
  -[AuthCredential mergeFrom:]
  -[AuthCredential dictionaryRepresentation]
  -[AuthCredential copyWithZone:]
  -[AuthCredential readFrom:]
  -[AuthCredential writeTo:]
  -[AuthCredential isEqual:]
  -[AuthCredential hasSimpleJwt]
  -[AuthCredential setSimpleJwt:]
  -[AuthCredential hasSharedOwnershipAuth]
  -[AuthCredential setSharedOwnershipAuth:]
  -[AuthCredential authCredentialOneof]
  -[AuthCredential setAuthCredentialOneof:]
  -[AuthCredential setHasAuthCredentialOneof:]
  -[AuthCredential hasAuthCredentialOneof]
  -[AuthCredential authCredentialOneofAsString:]
  -[AuthCredential StringAsAuthCredentialOneof:]
  -[AuthCredential clearOneofValuesForAuthCredentialOneof]
  -[AuthCredential simpleJwt]
  -[AuthCredential sharedOwnershipAuth]


SharedChannelPublishRequest : PBRequest <NSCopying>
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelPublishPayload
 @property  ChannelPublishPayload *channelPublishPayload

  // instance methods
  -[SharedChannelPublishRequest copyTo:]
  -[SharedChannelPublishRequest .cxx_destruct]
  -[SharedChannelPublishRequest mergeFrom:]
  -[SharedChannelPublishRequest dictionaryRepresentation]
  -[SharedChannelPublishRequest copyWithZone:]
  -[SharedChannelPublishRequest readFrom:]
  -[SharedChannelPublishRequest writeTo:]
  -[SharedChannelPublishRequest isEqual:]
  -[SharedChannelPublishRequest hasAuthCredential]
  -[SharedChannelPublishRequest authCredential]
  -[SharedChannelPublishRequest setAuthCredential:]
  -[SharedChannelPublishRequest hasChannelPublishPayload]
  -[SharedChannelPublishRequest channelPublishPayload]
  -[SharedChannelPublishRequest setChannelPublishPayload:]


ChannelPublishPayload : PBCodable <NSCopying>
 @property  BOOL hasPublishInitiateTimestampMillis
 @property  unsigned long publishInitiateTimestampMillis
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasPublishPayload
 @property  NSData *publishPayload
 @property  BOOL hasPublishPayloadExpiryTtlMillis
 @property  unsigned long publishPayloadExpiryTtlMillis
 @property  BOOL hasPushPriority
 @property  int pushPriority
 @property  BOOL hasPendingPublishHint
 @property  BOOL pendingPublishHint
 @property  BOOL hasScheduledPublishHint
 @property  BOOL scheduledPublishHint
 @property  BOOL hasRetryCount
 @property  unsigned int retryCount

  // instance methods
  -[ChannelPublishPayload copyTo:]
  -[ChannelPublishPayload retryCount]
  -[ChannelPublishPayload setRetryCount:]
  -[ChannelPublishPayload .cxx_destruct]
  -[ChannelPublishPayload mergeFrom:]
  -[ChannelPublishPayload dictionaryRepresentation]
  -[ChannelPublishPayload copyWithZone:]
  -[ChannelPublishPayload readFrom:]
  -[ChannelPublishPayload writeTo:]
  -[ChannelPublishPayload isEqual:]
  -[ChannelPublishPayload setPushPriority:]
  -[ChannelPublishPayload pushPriority]
  -[ChannelPublishPayload hasRetryCount]
  -[ChannelPublishPayload setHasRetryCount:]
  -[ChannelPublishPayload hasChannelIdentity]
  -[ChannelPublishPayload channelIdentity]
  -[ChannelPublishPayload setChannelIdentity:]
  -[ChannelPublishPayload setPublishInitiateTimestampMillis:]
  -[ChannelPublishPayload setHasPublishInitiateTimestampMillis:]
  -[ChannelPublishPayload hasPublishInitiateTimestampMillis]
  -[ChannelPublishPayload hasPublishPayload]
  -[ChannelPublishPayload setPublishPayloadExpiryTtlMillis:]
  -[ChannelPublishPayload setHasPublishPayloadExpiryTtlMillis:]
  -[ChannelPublishPayload hasPublishPayloadExpiryTtlMillis]
  -[ChannelPublishPayload setHasPushPriority:]
  -[ChannelPublishPayload hasPushPriority]
  -[ChannelPublishPayload pushPriorityAsString:]
  -[ChannelPublishPayload StringAsPushPriority:]
  -[ChannelPublishPayload setPendingPublishHint:]
  -[ChannelPublishPayload setHasPendingPublishHint:]
  -[ChannelPublishPayload hasPendingPublishHint]
  -[ChannelPublishPayload setScheduledPublishHint:]
  -[ChannelPublishPayload setHasScheduledPublishHint:]
  -[ChannelPublishPayload hasScheduledPublishHint]
  -[ChannelPublishPayload publishInitiateTimestampMillis]
  -[ChannelPublishPayload publishPayload]
  -[ChannelPublishPayload setPublishPayload:]
  -[ChannelPublishPayload publishPayloadExpiryTtlMillis]
  -[ChannelPublishPayload pendingPublishHint]
  -[ChannelPublishPayload scheduledPublishHint]


SKAStatusServer : NSObject <NSXPCListenerDelegate, SKADatabaseProvidingDelegate, SKAMessagingProvidingDelegate, SKAChannelManagingDelegate, SKAStatusReceivingManagingDelegate, SKADatabaseManagingDelegate, SKAInvitationManagingDelegate, SKAStatusPublishingServiceClientDelegate, SKAStatusSubscriptionServiceClientDelegate, SKAPresenceClientDelegate, SKAPresenceManagingDelegate>
 @property  NSXPCListener *publishingServiceListener
 @property  NSObject<OS_dispatch_queue> *publishingServiceConnectionQueue
 @property  NSMutableArray *publishingServiceConnectedClients
 @property  NSXPCListener *subscriptionServiceListener
 @property  NSObject<OS_dispatch_queue> *subscriptionServiceConnectionQueue
 @property  NSMutableArray *subscriptionServiceConnectedClients
 @property  NSXPCListener *presenceListener
 @property  NSObject<OS_dispatch_queue> *presenceConnectionQueue
 @property  NSMutableArray *presenceConnectedClients
 @property  <SKADatabaseProviding> *databaseProvider
 @property  <SKADatabaseManaging> *databaseManager
 @property  NSObject<OS_dispatch_queue> *invitationManagerMessagingQueue
 @property  <SKAMessagingProviding> *invitationMessagingProvider
 @property  <SKAInvitationManaging> *invitationManager
 @property  <SKAChannelManaging> *channelManager
 @property  <SKAStatusPublishingManaging> *publishingManager
 @property  <SKAStatusSubscriptionManaging> *subscriptionManager
 @property  <SKAPresenceManaging> *presenceManager
 @property  <SKAStatusEncryptionManaging> *encryptionManager
 @property  <SKAStatusReceivingManaging> *statusReceivingManager
 @property  BOOL trafficModeEnabled
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAStatusServer logger]
  +[SKAStatusServer sharedInstance]

  // instance methods
  -[SKAStatusServer publishingServiceListener]
  -[SKAStatusServer databaseManager]
  -[SKAStatusServer setDatabaseProvider:]
  -[SKAStatusServer subscriptionServiceConnectedClients]
  -[SKAStatusServer presenceManager:didReceivePresentDevicesUpdateForPresenceIdentifier:]
  -[SKAStatusServer setInvitationManagerMessagingQueue:]
  -[SKAStatusServer publishingServiceConnectionQueue]
  -[SKAStatusServer _setupMaintenanceActivity]
  -[SKAStatusServer setPublishingServiceListener:]
  -[SKAStatusServer invitationManager]
  -[SKAStatusServer _shouldDonateToBiomeForStatusTypeIdentifier:]
  -[SKAStatusServer setTrafficModeEnabled:]
  -[SKAStatusServer publishingManager]
  -[SKAStatusServer publishingServiceClientWasInvalidated:]
  -[SKAStatusServer encryptionManager]
  -[SKAStatusServer statusReceivingManager:didReceiveStatusUpdate:onChannel:]
  -[SKAStatusServer presenceManager]
  -[SKAStatusServer setPublishingManager:]
  -[SKAStatusServer .cxx_destruct]
  -[SKAStatusServer setPublishingServiceConnectionQueue:]
  -[SKAStatusServer setSubscriptionServiceListener:]
  -[SKAStatusServer service:didReceiveIncomingMessage:fromID:toID:messageGuid:]
  -[SKAStatusServer invitationManager:didReceiveInvitation:forChannel:]
  -[SKAStatusServer _subscriptionServiceListener:shouldAcceptNewConnection:]
  -[SKAStatusServer _publishingServiceListener:shouldAcceptNewConnection:]
  -[SKAStatusServer subscriptionManager]
  -[SKAStatusServer presenceListener]
  -[SKAStatusServer setPresenceListener:]
  -[SKAStatusServer setPublishingServiceConnectedClients:]
  -[SKAStatusServer donateReceivedStatusToBiomeOnChannel:]
  -[SKAStatusServer setPresenceConnectedClients:]
  -[SKAStatusServer invitationManager:didRevokeInvitationOnChannel:]
  -[SKAStatusServer _inTextTrafficMode]
  -[SKAStatusServer channelManager]
  -[SKAStatusServer setChannelManager:]
  -[SKAStatusServer subscriptionServiceClientWasInvalidated:]
  -[SKAStatusServer setSubscriptionServiceConnectionQueue:]
  -[SKAStatusServer _kettleFeatureEnabled]
  -[SKAStatusServer channelManager:failedToSubscribeToChannel:withError:]
  -[SKAStatusServer shutdown]
  -[SKAStatusServer subscriptionServiceConnectionQueue]
  -[SKAStatusServer setInvitationMessagingProvider:]
  -[SKAStatusServer setEncryptionManager:]
  -[SKAStatusServer setStatusReceivingManager:]
  -[SKAStatusServer databaseManager:didCreateChannel:]
  -[SKAStatusServer setSubscriptionManager:]
  -[SKAStatusServer databaseDidReceiveRemoteChangesForChannels:]
  -[SKAStatusServer setPresenceConnectionQueue:]
  -[SKAStatusServer trafficModeEnabled]
  -[SKAStatusServer subscriptionServiceListener]
  -[SKAStatusServer invitationManagerMessagingQueue]
  -[SKAStatusServer setDatabaseManager:]
  -[SKAStatusServer presenceConnectionQueue]
  -[SKAStatusServer statusReceivingManager]
  -[SKAStatusServer channelManager:didReceiveData:onChannel:dateReceived:dateExpired:]
  -[SKAStatusServer setInvitationManager:]
  -[SKAStatusServer presenceClientWasInvalidated:]
  -[SKAStatusServer setPresenceManager:]
  -[SKAStatusServer invitationMessagingProvider]
  -[SKAStatusServer _senderHandlesForChannel:]
  -[SKAStatusServer setSubscriptionServiceConnectedClients:]
  -[SKAStatusServer publishingServiceConnectedClients]
  -[SKAStatusServer listener:shouldAcceptNewConnection:]
  -[SKAStatusServer networkBecameReachable]
  -[SKAStatusServer init]
  -[SKAStatusServer presenceConnectedClients]
  -[SKAStatusServer logState]
  -[SKAStatusServer databaseProvider]
  -[SKAStatusServer _presenceServiceListener:shouldAcceptNewConnection:]


SKADatabaseRemovedUser : NSObject
 @property  NSString *handle
 @property  NSString *statusTypeIdentifier
 @property  NSString *presenceIdentifier
 @property  NSDate *dateRemoved

  // instance methods
  -[SKADatabaseRemovedUser dateRemoved]
  -[SKADatabaseRemovedUser handle]
  -[SKADatabaseRemovedUser .cxx_destruct]
  -[SKADatabaseRemovedUser statusTypeIdentifier]
  -[SKADatabaseRemovedUser presenceIdentifier]
  -[SKADatabaseRemovedUser initWithCoreDataRemovedUser:]
  -[SKADatabaseRemovedUser initWithHandle:statusTypeIdentifier:presenceIdentifier:dateRemoved:]


SKADatabaseProvider : NSObject <SKADatabaseProviding>
 @property  NSObject<OS_dispatch_queue> *historyProcessingQueue
 @property  NSPersistentContainer *persistentContainer
 @property  CKContainer *ckContainer
 @property  <SKADatabaseProvidingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKADatabaseProvider logger]

  // instance methods
  -[SKADatabaseProvider persistentContainer]
  -[SKADatabaseProvider createPersistentContainer]
  -[SKADatabaseProvider setHistoryProcessingQueue:]
  -[SKADatabaseProvider setDelegate:]
  -[SKADatabaseProvider extractModifiedChannelFromPersistentStoreRemoteChangeForReceivedInvitation:managedObjectContext:]
  -[SKADatabaseProvider containerName]
  -[SKADatabaseProvider delegate]
  -[SKADatabaseProvider setCkContainer:]
  -[SKADatabaseProvider localPersistentStoreDescription]
  -[SKADatabaseProvider .cxx_destruct]
  -[SKADatabaseProvider setPersistentContainer:]
  -[SKADatabaseProvider localDatabaseFileURL]
  -[SKADatabaseProvider deviceToDeviceEncryptedDatabaseCapableWithCompletion:]
  -[SKADatabaseProvider databaseDirectoryURL]
  -[SKADatabaseProvider initWithDelegate:]
  -[SKADatabaseProvider ckContainer]
  -[SKADatabaseProvider historyProcessingQueue]
  -[SKADatabaseProvider fileManager]
  -[SKADatabaseProvider cloudDatabaseFileURL]
  -[SKADatabaseProvider ckContainerIdentifier]
  -[SKADatabaseProvider handlePersistentStoreRemoteChangeNotification:]
  -[SKADatabaseProvider processPersistentStoreRemoteChanges]
  -[SKADatabaseProvider createCkContainer]
  -[SKADatabaseProvider existingManagedObjectWithID:managedObjectContext:]
  -[SKADatabaseProvider appTransactionAuthorName]
  -[SKADatabaseProvider lastProcessedPersistentHistoryTokenFileURL]
  -[SKADatabaseProvider lastProcessedPersistentHistoryToken]
  -[SKADatabaseProvider setLastProcessedPersistentHistoryToken:]
  -[SKADatabaseProvider databaseHasBeenCreated]
  -[SKADatabaseProvider newBackgroundContext]
  -[SKADatabaseProvider extractModifiedChannelFromPersistentStoreRemoteChangeForChannel:managedObjectContext:]
  -[SKADatabaseProvider cloudPersistentStoreDescription]
  -[SKADatabaseProvider overrideDeviceEncryptionCheck]


SKAGeneratedEncryptionKey : NSObject
 @property  MPStatusKitOutgoingRatchet *outgoingRatchet
 @property  MPStatusKitIncomingRatchet *incomingRatchet
 @property  NSData *originalOutgoingRatchetState
 @property  NSDate *dateGenerated

  // class methods
  +[SKAGeneratedEncryptionKey logger]

  // instance methods
  -[SKAGeneratedEncryptionKey .cxx_destruct]
  -[SKAGeneratedEncryptionKey dateGenerated]
  -[SKAGeneratedEncryptionKey initWithCoreDataGeneratedEncryptionKey:]
  -[SKAGeneratedEncryptionKey incomingRatchet]
  -[SKAGeneratedEncryptionKey initWithOriginalOutgoingRatchetState:dateGenerated:]
  -[SKAGeneratedEncryptionKey originalOutgoingRatchetState]
  -[SKAGeneratedEncryptionKey outgoingRatchet]


SKAStatusSubscriptionServiceClientConnection : NSObject
 @property  NSXPCConnection *xpcConnection
 @property  <SKAStatusSubscriptionServiceClientConnectionLifecycleDelegate> *connectionLifecycleDelegate
 @property  int processIdentifier

  // class methods
  +[SKAStatusSubscriptionServiceClientConnection logger]
  +[SKAStatusSubscriptionServiceClientConnection clientIsEntitledForAtLeastOneSubscriptionServiceType:]
  +[SKAStatusSubscriptionServiceClientConnection _connection:isEntitledForSubscriptionWithStatusTypeIdentifier:]

  // instance methods
  -[SKAStatusSubscriptionServiceClientConnection xpcConnection]
  -[SKAStatusSubscriptionServiceClientConnection dealloc]
  -[SKAStatusSubscriptionServiceClientConnection .cxx_destruct]
  -[SKAStatusSubscriptionServiceClientConnection setXpcConnection:]
  -[SKAStatusSubscriptionServiceClientConnection processIdentifier]
  -[SKAStatusSubscriptionServiceClientConnection initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:]
  -[SKAStatusSubscriptionServiceClientConnection asynchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusSubscriptionServiceClientConnection synchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAStatusSubscriptionServiceClientConnection connectionLifecycleDelegate]
  -[SKAStatusSubscriptionServiceClientConnection setConnectionLifecycleDelegate:]
  -[SKAStatusSubscriptionServiceClientConnection clientIsEntitledForAtLeastOneSubscriptionServiceType]
  -[SKAStatusSubscriptionServiceClientConnection clientIsEntitledForSubscriptionWithStatusTypeIdentifier:]


ChannelActivityUpdate : PBCodable <NSCopying>
 @property  BOOL hasCurrentVersion
 @property  unsigned long currentVersion
 @property  BOOL hasPrevVersion
 @property  unsigned long prevVersion
 @property  BOOL hasEncryptedUpdatePayload
 @property  NSData *encryptedUpdatePayload

  // instance methods
  -[ChannelActivityUpdate currentVersion]
  -[ChannelActivityUpdate copyTo:]
  -[ChannelActivityUpdate .cxx_destruct]
  -[ChannelActivityUpdate mergeFrom:]
  -[ChannelActivityUpdate dictionaryRepresentation]
  -[ChannelActivityUpdate copyWithZone:]
  -[ChannelActivityUpdate readFrom:]
  -[ChannelActivityUpdate writeTo:]
  -[ChannelActivityUpdate isEqual:]
  -[ChannelActivityUpdate setCurrentVersion:]
  -[ChannelActivityUpdate setHasCurrentVersion:]
  -[ChannelActivityUpdate hasCurrentVersion]
  -[ChannelActivityUpdate setPrevVersion:]
  -[ChannelActivityUpdate setHasPrevVersion:]
  -[ChannelActivityUpdate hasPrevVersion]
  -[ChannelActivityUpdate hasEncryptedUpdatePayload]
  -[ChannelActivityUpdate prevVersion]
  -[ChannelActivityUpdate encryptedUpdatePayload]
  -[ChannelActivityUpdate setEncryptedUpdatePayload:]


SignedParticipantPayload : PBCodable <NSCopying>
 @property  BOOL hasPayload
 @property  DecryptedParticipantPayload *payload
 @property  BOOL hasSignature
 @property  NSData *signature

  // instance methods
  -[SignedParticipantPayload signature]
  -[SignedParticipantPayload setPayload:]
  -[SignedParticipantPayload copyTo:]
  -[SignedParticipantPayload payload]
  -[SignedParticipantPayload .cxx_destruct]
  -[SignedParticipantPayload mergeFrom:]
  -[SignedParticipantPayload hasPayload]
  -[SignedParticipantPayload dictionaryRepresentation]
  -[SignedParticipantPayload copyWithZone:]
  -[SignedParticipantPayload readFrom:]
  -[SignedParticipantPayload writeTo:]
  -[SignedParticipantPayload setSignature:]
  -[SignedParticipantPayload hasSignature]
  -[SignedParticipantPayload isEqual:]


ChannelActivityUpdatePayload : PBCodable <NSCopying>
 @property  BOOL hasUpdateType
 @property  int updateType
 @property  BOOL hasParticipantPayload
 @property  ChannelActivityParticipantPayload *participantPayload
 @property  BOOL hasPadding
 @property  NSData *padding

  // instance methods
  -[ChannelActivityUpdatePayload copyTo:]
  -[ChannelActivityUpdatePayload padding]
  -[ChannelActivityUpdatePayload setUpdateType:]
  -[ChannelActivityUpdatePayload .cxx_destruct]
  -[ChannelActivityUpdatePayload mergeFrom:]
  -[ChannelActivityUpdatePayload dictionaryRepresentation]
  -[ChannelActivityUpdatePayload updateType]
  -[ChannelActivityUpdatePayload copyWithZone:]
  -[ChannelActivityUpdatePayload readFrom:]
  -[ChannelActivityUpdatePayload setPadding:]
  -[ChannelActivityUpdatePayload writeTo:]
  -[ChannelActivityUpdatePayload isEqual:]
  -[ChannelActivityUpdatePayload hasPadding]
  -[ChannelActivityUpdatePayload setHasUpdateType:]
  -[ChannelActivityUpdatePayload hasUpdateType]
  -[ChannelActivityUpdatePayload updateTypeAsString:]
  -[ChannelActivityUpdatePayload StringAsUpdateType:]
  -[ChannelActivityUpdatePayload hasParticipantPayload]
  -[ChannelActivityUpdatePayload participantPayload]
  -[ChannelActivityUpdatePayload setParticipantPayload:]


ChannelActivityActivationRequest : PBRequest <NSCopying>
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasRequestFlag
 @property  int requestFlag
 @property  BOOL hasUuid
 @property  NSData *uuid
 @property  BOOL hasClientTimestampSeconds
 @property  unsigned long clientTimestampSeconds
 @property  BOOL hasEncryptedParticipantPayload
 @property  NSData *encryptedParticipantPayload

  // instance methods
  -[ChannelActivityActivationRequest copyTo:]
  -[ChannelActivityActivationRequest uuid]
  -[ChannelActivityActivationRequest hasUuid]
  -[ChannelActivityActivationRequest .cxx_destruct]
  -[ChannelActivityActivationRequest setUuid:]
  -[ChannelActivityActivationRequest mergeFrom:]
  -[ChannelActivityActivationRequest dictionaryRepresentation]
  -[ChannelActivityActivationRequest copyWithZone:]
  -[ChannelActivityActivationRequest readFrom:]
  -[ChannelActivityActivationRequest writeTo:]
  -[ChannelActivityActivationRequest isEqual:]
  -[ChannelActivityActivationRequest hasAuthCredential]
  -[ChannelActivityActivationRequest authCredential]
  -[ChannelActivityActivationRequest setAuthCredential:]
  -[ChannelActivityActivationRequest hasEncryptedParticipantPayload]
  -[ChannelActivityActivationRequest encryptedParticipantPayload]
  -[ChannelActivityActivationRequest setEncryptedParticipantPayload:]
  -[ChannelActivityActivationRequest hasChannelIdentity]
  -[ChannelActivityActivationRequest channelIdentity]
  -[ChannelActivityActivationRequest setChannelIdentity:]
  -[ChannelActivityActivationRequest setClientTimestampSeconds:]
  -[ChannelActivityActivationRequest setHasClientTimestampSeconds:]
  -[ChannelActivityActivationRequest hasClientTimestampSeconds]
  -[ChannelActivityActivationRequest clientTimestampSeconds]
  -[ChannelActivityActivationRequest requestFlag]
  -[ChannelActivityActivationRequest setRequestFlag:]
  -[ChannelActivityActivationRequest setHasRequestFlag:]
  -[ChannelActivityActivationRequest hasRequestFlag]
  -[ChannelActivityActivationRequest requestFlagAsString:]
  -[ChannelActivityActivationRequest StringAsRequestFlag:]


SKADecryptedStatusPayload : NSObject
 @property  SKStatusPayload *statusPayload
 @property  SKADatabaseReceivedInvitation *invitation

  // instance methods
  -[SKADecryptedStatusPayload .cxx_destruct]
  -[SKADecryptedStatusPayload invitation]
  -[SKADecryptedStatusPayload statusPayload]
  -[SKADecryptedStatusPayload initWithStatusPayload:invitation:]


SKADatabaseInvitedUser : NSObject
 @property  SKHandle *invitedSKHandle
 @property  SKHandle *senderSKHandle
 @property  SKInvitationPayload *invitationPayload
 @property  NSString *invitedHandle
 @property  NSString *senderHandle
 @property  NSData *invitationPayloadData
 @property  NSDate *dateInvitationPayloadCreated

  // instance methods
  -[SKADatabaseInvitedUser .cxx_destruct]
  -[SKADatabaseInvitedUser senderHandle]
  -[SKADatabaseInvitedUser invitationPayload]
  -[SKADatabaseInvitedUser initWithCoreDataInvitedUser:]
  -[SKADatabaseInvitedUser invitedHandle]
  -[SKADatabaseInvitedUser invitedSKHandle]
  -[SKADatabaseInvitedUser senderSKHandle]
  -[SKADatabaseInvitedUser initWithInvitedHandle:senderHande:invitationPayloadData:dateInvitationPayloadCreated:]
  -[SKADatabaseInvitedUser invitationPayloadData]
  -[SKADatabaseInvitedUser dateInvitationPayloadCreated]


SKADatabaseManager : NSObject <SKADatabaseManaging>
 @property  <SKADatabaseProviding> *databaseProvider
 @property  <SKADatabaseManagingDelegate> *delegate
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKADatabaseManager logger]

  // instance methods
  -[SKADatabaseManager createRemovedUserWithHandle:dateRemoved:presenceIdentifier:databaseContext:]
  -[SKADatabaseManager _existingRemovedUsersForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager decomissionAllPersonalChannelsWithStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingDecomissionedPersonalChannelsWithDatabaseContext:]
  -[SKADatabaseManager createRemovedUserWithHandle:dateRemoved:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingPersonalChannelsForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingInvitedUsersForDatabaseInvitedUser:databaseChannel:databaseContext:]
  -[SKADatabaseManager _existingChannelCheckpointForChannelIdentifier:databaseContext:]
  -[SKADatabaseManager _existingChannelsForChannelIdentifier:databaseContext:]
  -[SKADatabaseManager delegate]
  -[SKADatabaseManager deletePendingPublishRequestWithWithUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager createInvitedUserWithHandle:senderHandle:invitationPayload:channel:databaseContext:]
  -[SKADatabaseManager existingPendingPublishRequestForUniqueIdentifier:withDatabaseContext:]
  -[SKADatabaseManager createSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager .cxx_destruct]
  -[SKADatabaseManager allExistingChannelsForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager deleteInvitedUserForHandle:personalChannel:databaseContext:]
  -[SKADatabaseManager existingStatusForChannel:databaseContext:]
  -[SKADatabaseManager createOrUpdateTransientSubscriptionHistoryForChannelIdentifier:lastSubscriptionDate:databaseContext:]
  -[SKADatabaseManager deleteRemovedUserWithHandle:presenceIdentifier:databaseContext:]
  -[SKADatabaseManager deviceToDeviceEncryptedDatabaseCapableWithCompletion:]
  -[SKADatabaseManager createChannelForStatusTypeIdentifier:channelIdentifier:databaseContext:]
  -[SKADatabaseManager receivedInvitationsForChannel:databaseContext:]
  -[SKADatabaseManager _existingPendingPublishRequestsWithDatabaseContext:]
  -[SKADatabaseManager _existingPersonalChannelForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager allPersistentSubscriptionAssertionChannelIdentifiersWithDatabaseContext:]
  -[SKADatabaseManager copyInvitedUsersFromChannel:toChannel:databaseContext:]
  -[SKADatabaseManager existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager cleanupOldStatusUpdatesForChannelIdentifier:excludingStatusUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager existingPendingPublishRequestsWithDatabaseContext:]
  -[SKADatabaseManager _existingRemovedUsersForHandle:presenceIdentifier:databaseContext:]
  -[SKADatabaseManager existingRemovedUserWithHandle:statusTypeIdentifier:withDatabaseContext:]
  -[SKADatabaseManager createReceivedInvitationForChannel:senderHandle:invitedHandle:invitationIdentifier:dateInvitationCreated:incomingRatchetState:presenceIdentifier:channelToken:serverKey:peerKey:invitationPayload:databaseContext:]
  -[SKADatabaseManager existingInvitedUsersForPersonalChannel:databaseContext:]
  -[SKADatabaseManager existingChannelForSubscriptionIdentifier:databaseContext:]
  -[SKADatabaseManager _existingTransientSubscriptionHistoryForChannelIdentifier:databaseContext:]
  -[SKADatabaseManager existingPendingPublishRequestsForStatusTypeIdentifier:withDatabaseContext:]
  -[SKADatabaseManager allExistingChannelsForStatusTypeIdentifier:includingPersonalChannel:databaseContext:]
  -[SKADatabaseManager _existingPendingPublishRequestForUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager createPersonalChannelForStatusTypeIdentifier:channelIdentifier:channelToken:databaseContext:]
  -[SKADatabaseManager _existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager cleanupOldReceivedInvitationsForChannelIdentifier:excludingInvitation:databaseContext:]
  -[SKADatabaseManager deleteSubscriptionAssertionWithSubscriptionIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager setCurrentCheckpointForChannel:checkpoint:databaseContext:]
  -[SKADatabaseManager existingChannelForPresenceIdentifier:databaseContext:]
  -[SKADatabaseManager existingInvitedUsersForInvitedHandle:onChannel:databaseContext:]
  -[SKADatabaseManager _existingTransientSubscriptionHistoryWithLimit:orderedByLastSubscriptionDateAscending:databaseContext:]
  -[SKADatabaseManager _existingPersonalChannelForDatabaseChannel:databaseContext:]
  -[SKADatabaseManager existingRecentTransientSubscriptionHistoriesWithLimit:databaseContext:]
  -[SKADatabaseManager _existingChannelsForDatabaseChannel:databaseContext:]
  -[SKADatabaseManager incrementPendingPublishRequestRetryCountWithUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager currentCheckpointForChannel:databaseContext:]
  -[SKADatabaseManager initWithDatabaseProvider:delegate:]
  -[SKADatabaseManager createGeneratedEncryptionKeyWithOriginalOutgoingRatchetState:personalChannel:databaseContext:]
  -[SKADatabaseManager createPendingPublishRequestWithUniqueIdentifier:dateCreated:payloadData:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingSubscriptionAssertionsForStatusTypeIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager generatedEncryptionKeysForPersonalChannel:databaseContext:]
  -[SKADatabaseManager createPresenceChannelForPresenceIdentifier:channelIdentifier:channelToken:peerKey:serverKey:membershipKey:databaseContext:]
  -[SKADatabaseManager existingPersonalChannelForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingChannelsForPresenceIdentifier:databaseContext:]
  -[SKADatabaseManager createStatusWithUniqueIdentifier:dateCreated:datePublished:dateReceived:dateExpired:rawData:channelIdentifier:databaseContext:]
  -[SKADatabaseManager _existingReceivedInvitationsForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager cleanupDecommisionedChannelsWithDatabaseContext:]
  -[SKADatabaseManager decomissionChannelWithIdentifier:databaseContext:]
  -[SKADatabaseManager existingChannelForHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager deleteAllInvitedUsersForPersonalChannel:databaseContext:]
  -[SKADatabaseManager existingStatusForUniqueIdentifier:databaseContext:]
  -[SKADatabaseManager deleteRemovedUserWithHandle:statusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingPendingPublishRequestsForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager newBackgroundContext]
  -[SKADatabaseManager deletePersonalChannelForStatusTypeIdentifier:databaseContext:]
  -[SKADatabaseManager _existingReceivedInvitationsForChannelIdentifier:sortedByDateReceived:databaseContect:]
  -[SKADatabaseManager existingSubscriptionAssertionForSubscriptionIdentifier:applicationIdentifier:databaseContext:]
  -[SKADatabaseManager updatePersonalChannel:withCurrentOutgoingRatchetState:databaseContext:]
  -[SKADatabaseManager databaseProvider]
  -[SKADatabaseManager _existingInvitedUsersForInvitedHandle:channel:databaseContext:]
  -[SKADatabaseManager updateInvitationPayload:onExistingInvitedUser:channel:databaseContext:]
  -[SKADatabaseManager existingRemovedUserWithHandle:presenceIdentifier:withDatabaseContext:]
  -[SKADatabaseManager cleanupOldChannelsForHandle:statusTypeIdentifier:databaseContext:]


SKADatabaseSubscriptionAssertion : NSObject
 @property  NSString *channelIdentifier
 @property  NSString *statusTypeIdentifier
 @property  NSString *applicationIdentifier

  // instance methods
  -[SKADatabaseSubscriptionAssertion applicationIdentifier]
  -[SKADatabaseSubscriptionAssertion .cxx_destruct]
  -[SKADatabaseSubscriptionAssertion statusTypeIdentifier]
  -[SKADatabaseSubscriptionAssertion channelIdentifier]
  -[SKADatabaseSubscriptionAssertion initWithCoreDataSubscriptionAssertion:]
  -[SKADatabaseSubscriptionAssertion initWithChannelIdentifier:statusTypeIdentifier:applicationIdentifier:]


ChannelActivityPollingRequest : PBRequest <NSCopying>
 @property  BOOL hasAuthCredential
 @property  AuthCredential *authCredential
 @property  BOOL hasChannelIdentity
 @property  ChannelIdentity *channelIdentity
 @property  BOOL hasRequestFlag
 @property  int requestFlag
 @property  BOOL hasUuid
 @property  NSData *uuid

  // instance methods
  -[ChannelActivityPollingRequest copyTo:]
  -[ChannelActivityPollingRequest uuid]
  -[ChannelActivityPollingRequest hasUuid]
  -[ChannelActivityPollingRequest .cxx_destruct]
  -[ChannelActivityPollingRequest setUuid:]
  -[ChannelActivityPollingRequest mergeFrom:]
  -[ChannelActivityPollingRequest dictionaryRepresentation]
  -[ChannelActivityPollingRequest copyWithZone:]
  -[ChannelActivityPollingRequest readFrom:]
  -[ChannelActivityPollingRequest writeTo:]
  -[ChannelActivityPollingRequest isEqual:]
  -[ChannelActivityPollingRequest hasAuthCredential]
  -[ChannelActivityPollingRequest authCredential]
  -[ChannelActivityPollingRequest setAuthCredential:]
  -[ChannelActivityPollingRequest hasChannelIdentity]
  -[ChannelActivityPollingRequest channelIdentity]
  -[ChannelActivityPollingRequest setChannelIdentity:]
  -[ChannelActivityPollingRequest requestFlag]
  -[ChannelActivityPollingRequest setRequestFlag:]
  -[ChannelActivityPollingRequest setHasRequestFlag:]
  -[ChannelActivityPollingRequest hasRequestFlag]
  -[ChannelActivityPollingRequest requestFlagAsString:]
  -[ChannelActivityPollingRequest StringAsRequestFlag:]


SKAPresenceClient : NSObject <SKPresenceDaemonProtocol, SKAClientConnectionRepresentable, SKAPresenceClientConnectionLifecycleDelegate>
 @property  SKAPresenceClientConnection *clientConnection
 @property  <SKAPresenceClientDelegate> *delegate
 @property  <SKADatabaseManaging> *databaseManager
 @property  <SKAStatusSubscriptionManaging> *subscriptionManager
 @property  <SKAInvitationManaging> *invitationManager
 @property  <SKAPresenceManaging> *presenceManager
 @property  BOOL accountCheckCompleted
 @property  BOOL accountIsPresenceCapable
 @property  NSObject<OS_dispatch_queue> *queue
 @property  NSSet *lastSeenPresentDevices
 @property  NSString *presenceIdenfifier
 @property  unsigned long hash
 @property  Class superclass
 @property  NSString *description
 @property  NSString *debugDescription

  // class methods
  +[SKAPresenceClient logger]
  +[SKAPresenceClient _accountNotCapableError]
  +[SKAPresenceClient _unableToResolveSenderHandleError]
  +[SKAPresenceClient _noChannelError]
  +[SKAPresenceClient _noChannelCreatedError]
  +[SKAPresenceClient _noClientIDError]

  // instance methods
  -[SKAPresenceClient databaseManager]
  -[SKAPresenceClient clientConnection]
  -[SKAPresenceClient setDelegate:]
  -[SKAPresenceClient setClientConnection:]
  -[SKAPresenceClient invitationManager]
  -[SKAPresenceClient fetchHandleInvitability:fromHandle:forPresenceIdentifier:completion:]
  -[SKAPresenceClient delegate]
  -[SKAPresenceClient presenceManager]
  -[SKAPresenceClient .cxx_destruct]
  -[SKAPresenceClient presentDevicesForPresenceIdentifier:completion:]
  -[SKAPresenceClient subscriptionManager]
  -[SKAPresenceClient setQueue:]
  -[SKAPresenceClient queue]
  -[SKAPresenceClient setSubscriptionManager:]
  -[SKAPresenceClient setDatabaseManager:]
  -[SKAPresenceClient setInvitationManager:]
  -[SKAPresenceClient setPresenceManager:]
  -[SKAPresenceClient invitedHandlesForPresenceIdentifier:completion:]
  -[SKAPresenceClient isHandleInvited:fromSenderHandle:forPresenceIdentifier:completion:]
  -[SKAPresenceClient inviteHandles:fromSenderHandle:presenceIdentifier:completion:]
  -[SKAPresenceClient removeInvitedHandles:presenceIdentifier:completion:]
  -[SKAPresenceClient retainTransientSubscriptionAssertionForPresenceIdentifier:completion:]
  -[SKAPresenceClient releaseTransientSubscriptionAssertionForPresenceIdentifier:completion:]
  -[SKAPresenceClient assertPresenceForIdentifier:completion:]
  -[SKAPresenceClient releasePresenceForIdentifier:completion:]
  -[SKAPresenceClient fetchPresenceCapability:]
  -[SKAPresenceClient registerForDelegateCallbacksWithPresenceIdentifier:completion:]
  -[SKAPresenceClient accountCheckCompleted]
  -[SKAPresenceClient setAccountCheckCompleted:]
  -[SKAPresenceClient presenceClientConnectionWasInvalidated:]
  -[SKAPresenceClient presenceClientConnectionWasInterrupted:]
  -[SKAPresenceClient initWithXPCConnection:queue:delegate:subscriptionManager:presenceManager:invitationManager:databaseManager:]
  -[SKAPresenceClient clientPrefixedPresenceIdentifierForPresenceIdentifier:]
  -[SKAPresenceClient rawPresenceIdentifierForPrefixedPresenceIdentifier:]
  -[SKAPresenceClient _shortHashOfClientID:]
  -[SKAPresenceClient accountIsPresenceCapableWithCompletion:]
  -[SKAPresenceClient presenceIdentifierMatchesClient:]
  -[SKAPresenceClient handleReceivedPresentDevicesUpdateForPresenceIdentifier:]
  -[SKAPresenceClient handleReceivedInvitationForPresenceIdentifier:]
  -[SKAPresenceClient presenceIdenfifier]
  -[SKAPresenceClient accountIsPresenceCapable]
  -[SKAPresenceClient setAccountIsPresenceCapable:]
  -[SKAPresenceClient lastSeenPresentDevices]
  -[SKAPresenceClient setLastSeenPresentDevices:]


ChannelActivityDeactivationResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasUuid
 @property  NSData *uuid
 @property  BOOL hasServerTimestampSeconds
 @property  unsigned long serverTimestampSeconds

  // instance methods
  -[ChannelActivityDeactivationResponse copyTo:]
  -[ChannelActivityDeactivationResponse setHasStatus:]
  -[ChannelActivityDeactivationResponse hasStatus]
  -[ChannelActivityDeactivationResponse status]
  -[ChannelActivityDeactivationResponse setStatus:]
  -[ChannelActivityDeactivationResponse uuid]
  -[ChannelActivityDeactivationResponse statusAsString:]
  -[ChannelActivityDeactivationResponse hasUuid]
  -[ChannelActivityDeactivationResponse .cxx_destruct]
  -[ChannelActivityDeactivationResponse setUuid:]
  -[ChannelActivityDeactivationResponse mergeFrom:]
  -[ChannelActivityDeactivationResponse StringAsStatus:]
  -[ChannelActivityDeactivationResponse dictionaryRepresentation]
  -[ChannelActivityDeactivationResponse copyWithZone:]
  -[ChannelActivityDeactivationResponse readFrom:]
  -[ChannelActivityDeactivationResponse writeTo:]
  -[ChannelActivityDeactivationResponse isEqual:]
  -[ChannelActivityDeactivationResponse setServerTimestampSeconds:]
  -[ChannelActivityDeactivationResponse setHasServerTimestampSeconds:]
  -[ChannelActivityDeactivationResponse hasServerTimestampSeconds]
  -[ChannelActivityDeactivationResponse serverTimestampSeconds]


SKADatabasePendingPublishRequest : NSObject
 @property  NSString *statusTypeIdentifier
 @property  NSDate *dateCreated
 @property  NSData *payloadData
 @property  NSString *statusUniqueIdentifier
 @property  long long retryCount

  // instance methods
  -[SKADatabasePendingPublishRequest retryCount]
  -[SKADatabasePendingPublishRequest dateCreated]
  -[SKADatabasePendingPublishRequest .cxx_destruct]
  -[SKADatabasePendingPublishRequest statusTypeIdentifier]
  -[SKADatabasePendingPublishRequest payloadData]
  -[SKADatabasePendingPublishRequest statusUniqueIdentifier]
  -[SKADatabasePendingPublishRequest initWithCoreDataPendingPublishRequest:]
  -[SKADatabasePendingPublishRequest initWithStatusTypeIdentifier:dateCreated:payloadData:statusUniqueIdentifier:retryCount:]


SharedChannelActivityResponse : PBCodable <NSCopying>
 @property  BOOL hasActivationResponse
 @property  ChannelActivityActivationResponse *activationResponse
 @property  BOOL hasDeactivationResponse
 @property  ChannelActivityDeactivationResponse *deactivationResponse
 @property  BOOL hasPollingResponse
 @property  ChannelActivityPollingResponse *pollingResponse
 @property  BOOL hasResponse
 @property  int response

  // instance methods
  -[SharedChannelActivityResponse copyTo:]
  -[SharedChannelActivityResponse activationResponse]
  -[SharedChannelActivityResponse .cxx_destruct]
  -[SharedChannelActivityResponse hasResponse]
  -[SharedChannelActivityResponse setActivationResponse:]
  -[SharedChannelActivityResponse mergeFrom:]
  -[SharedChannelActivityResponse setResponse:]
  -[SharedChannelActivityResponse dictionaryRepresentation]
  -[SharedChannelActivityResponse copyWithZone:]
  -[SharedChannelActivityResponse readFrom:]
  -[SharedChannelActivityResponse response]
  -[SharedChannelActivityResponse writeTo:]
  -[SharedChannelActivityResponse isEqual:]
  -[SharedChannelActivityResponse setHasResponse:]
  -[SharedChannelActivityResponse responseAsString:]
  -[SharedChannelActivityResponse StringAsResponse:]
  -[SharedChannelActivityResponse hasActivationResponse]
  -[SharedChannelActivityResponse hasDeactivationResponse]
  -[SharedChannelActivityResponse setDeactivationResponse:]
  -[SharedChannelActivityResponse hasPollingResponse]
  -[SharedChannelActivityResponse setPollingResponse:]
  -[SharedChannelActivityResponse clearOneofValuesForResponse]
  -[SharedChannelActivityResponse deactivationResponse]
  -[SharedChannelActivityResponse pollingResponse]


SharedOwnershipAuth : PBCodable <NSCopying>
 @property  BOOL hasSimpleJwt
 @property  NSString *simpleJwt
 @property  BOOL hasChannelPublicKey
 @property  NSData *channelPublicKey
 @property  BOOL hasNonce
 @property  NSData *nonce
 @property  BOOL hasSignNonce
 @property  NSData *signNonce
 @property  BOOL hasServerEncryptionKey
 @property  NSData *serverEncryptionKey

  // instance methods
  -[SharedOwnershipAuth copyTo:]
  -[SharedOwnershipAuth .cxx_destruct]
  -[SharedOwnershipAuth mergeFrom:]
  -[SharedOwnershipAuth dictionaryRepresentation]
  -[SharedOwnershipAuth copyWithZone:]
  -[SharedOwnershipAuth readFrom:]
  -[SharedOwnershipAuth nonce]
  -[SharedOwnershipAuth writeTo:]
  -[SharedOwnershipAuth isEqual:]
  -[SharedOwnershipAuth setNonce:]
  -[SharedOwnershipAuth hasNonce]
  -[SharedOwnershipAuth hasSimpleJwt]
  -[SharedOwnershipAuth setSimpleJwt:]
  -[SharedOwnershipAuth simpleJwt]
  -[SharedOwnershipAuth hasChannelPublicKey]
  -[SharedOwnershipAuth hasSignNonce]
  -[SharedOwnershipAuth hasServerEncryptionKey]
  -[SharedOwnershipAuth channelPublicKey]
  -[SharedOwnershipAuth setChannelPublicKey:]
  -[SharedOwnershipAuth signNonce]
  -[SharedOwnershipAuth setSignNonce:]
  -[SharedOwnershipAuth serverEncryptionKey]
  -[SharedOwnershipAuth setServerEncryptionKey:]


SKAPresenceClientConnection : NSObject
 @property  NSXPCConnection *xpcConnection
 @property  <SKAPresenceClientConnectionLifecycleDelegate> *connectionLifecycleDelegate
 @property  int processIdentifier
 @property  NSString *clientID

  // class methods
  +[SKAPresenceClientConnection logger]
  +[SKAPresenceClientConnection _clientIDForConnection:]

  // instance methods
  -[SKAPresenceClientConnection clientID]
  -[SKAPresenceClientConnection xpcConnection]
  -[SKAPresenceClientConnection dealloc]
  -[SKAPresenceClientConnection .cxx_destruct]
  -[SKAPresenceClientConnection setXpcConnection:]
  -[SKAPresenceClientConnection processIdentifier]
  -[SKAPresenceClientConnection initWithXPCConnection:queue:daemonProtocolDelegate:connectionLifecycleDelegate:]
  -[SKAPresenceClientConnection asynchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAPresenceClientConnection synchronousRemoteDaemonDelegateWithErrorHandler:]
  -[SKAPresenceClientConnection connectionLifecycleDelegate]
  -[SKAPresenceClientConnection setConnectionLifecycleDelegate:]


ChannelActivityActivationResponse : PBCodable <NSCopying>
 @property  BOOL hasStatus
 @property  int status
 @property  BOOL hasUuid
 @property  NSData *uuid
 @property  BOOL hasServerTimestampSeconds
 @property  unsigned long serverTimestampSeconds
 @property  BOOL hasVersion
 @property  unsigned long version
 @property  NSMutableArray *participantPayloads
 @property  BOOL hasResponseMessageIndex
 @property  unsigned int responseMessageIndex
 @property  BOOL hasTotalResponseMessages
 @property  unsigned int totalResponseMessages
 @property  BOOL hasActivationExpirySeconds
 @property  unsigned int activationExpirySeconds

  // class methods
  +[ChannelActivityActivationResponse participantPayloadType]

  // instance methods
  -[ChannelActivityActivationResponse copyTo:]
  -[ChannelActivityActivationResponse setHasStatus:]
  -[ChannelActivityActivationResponse hasStatus]
  -[ChannelActivityActivationResponse status]
  -[ChannelActivityActivationResponse setStatus:]
  -[ChannelActivityActivationResponse uuid]
  -[ChannelActivityActivationResponse statusAsString:]
  -[ChannelActivityActivationResponse hasUuid]
  -[ChannelActivityActivationResponse .cxx_destruct]
  -[ChannelActivityActivationResponse setUuid:]
  -[ChannelActivityActivationResponse mergeFrom:]
  -[ChannelActivityActivationResponse hasVersion]
  -[ChannelActivityActivationResponse StringAsStatus:]
  -[ChannelActivityActivationResponse version]
  -[ChannelActivityActivationResponse dictionaryRepresentation]
  -[ChannelActivityActivationResponse copyWithZone:]
  -[ChannelActivityActivationResponse setHasVersion:]
  -[ChannelActivityActivationResponse readFrom:]
  -[ChannelActivityActivationResponse setVersion:]
  -[ChannelActivityActivationResponse writeTo:]
  -[ChannelActivityActivationResponse isEqual:]
  -[ChannelActivityActivationResponse setServerTimestampSeconds:]
  -[ChannelActivityActivationResponse setHasServerTimestampSeconds:]
  -[ChannelActivityActivationResponse hasServerTimestampSeconds]
  -[ChannelActivityActivationResponse clearParticipantPayloads]
  -[ChannelActivityActivationResponse addParticipantPayload:]
  -[ChannelActivityActivationResponse participantPayloadsCount]
  -[ChannelActivityActivationResponse participantPayloadAtIndex:]
  -[ChannelActivityActivationResponse setResponseMessageIndex:]
  -[ChannelActivityActivationResponse setHasResponseMessageIndex:]
  -[ChannelActivityActivationResponse hasResponseMessageIndex]
  -[ChannelActivityActivationResponse setTotalResponseMessages:]
  -[ChannelActivityActivationResponse setHasTotalResponseMessages:]
  -[ChannelActivityActivationResponse hasTotalResponseMessages]
  -[ChannelActivityActivationResponse serverTimestampSeconds]
  -[ChannelActivityActivationResponse participantPayloads]
  -[ChannelActivityActivationResponse setParticipantPayloads:]
  -[ChannelActivityActivationResponse responseMessageIndex]
  -[ChannelActivityActivationResponse totalResponseMessages]
  -[ChannelActivityActivationResponse setActivationExpirySeconds:]
  -[ChannelActivityActivationResponse setHasActivationExpirySeconds:]
  -[ChannelActivityActivationResponse hasActivationExpirySeconds]
  -[ChannelActivityActivationResponse activationExpirySeconds]


SKASystemMonitor : NSObject
 @property  {os_unfair_lock_s=I} ivarLock
 @property  BOOL underFirstLock
 @property  NSHashTable *listeners
 @property  BOOL isUnderFirstDataProtectionLock

  // class methods
  +[SKASystemMonitor logger]
  +[SKASystemMonitor sharedInstance]

  // instance methods
  -[SKASystemMonitor ivarLock]
  -[SKASystemMonitor setIvarLock:]
  -[SKASystemMonitor isUnderFirstDataProtectionLock]
  -[SKASystemMonitor _deviceStillUnderFirstLock]
  -[SKASystemMonitor addListener:]
  -[SKASystemMonitor removeListener:]
  -[SKASystemMonitor setListeners:]
  -[SKASystemMonitor listeners]
  -[SKASystemMonitor .cxx_destruct]
  -[SKASystemMonitor _updateLockState]
  -[SKASystemMonitor underFirstLock]
  -[SKASystemMonitor setUnderFirstLock:]
  -[SKASystemMonitor _listenForKeyBagChangeNotifications]
  -[SKASystemMonitor _deliverNotificationSelectorToListeners:]
  -[SKASystemMonitor init]


SharedChannelActivityRequest : PBRequest <NSCopying>
 @property  BOOL hasActivationRequest
 @property  ChannelActivityActivationRequest *activationRequest
 @property  BOOL hasDeactivationRequest
 @property  ChannelActivityDeactivationRequest *deactivationRequest
 @property  BOOL hasPollingRequest
 @property  ChannelActivityPollingRequest *pollingRequest
 @property  BOOL hasRequest
 @property  int request

  // instance methods
  -[SharedChannelActivityRequest hasRequest]
  -[SharedChannelActivityRequest copyTo:]
  -[SharedChannelActivityRequest setRequest:]
  -[SharedChannelActivityRequest .cxx_destruct]
  -[SharedChannelActivityRequest mergeFrom:]
  -[SharedChannelActivityRequest dictionaryRepresentation]
  -[SharedChannelActivityRequest copyWithZone:]
  -[SharedChannelActivityRequest readFrom:]
  -[SharedChannelActivityRequest writeTo:]
  -[SharedChannelActivityRequest isEqual:]
  -[SharedChannelActivityRequest request]
  -[SharedChannelActivityRequest setActivationRequest:]
  -[SharedChannelActivityRequest activationRequest]
  -[SharedChannelActivityRequest setHasRequest:]
  -[SharedChannelActivityRequest requestAsString:]
  -[SharedChannelActivityRequest StringAsRequest:]
  -[SharedChannelActivityRequest clearOneofValuesForRequest]
  -[SharedChannelActivityRequest hasActivationRequest]
  -[SharedChannelActivityRequest hasDeactivationRequest]
  -[SharedChannelActivityRequest setDeactivationRequest:]
  -[SharedChannelActivityRequest hasPollingRequest]
  -[SharedChannelActivityRequest setPollingRequest:]
  -[SharedChannelActivityRequest deactivationRequest]
  -[SharedChannelActivityRequest pollingRequest]


Channel : NSManagedObject
 @property  NSData *channelToken
 @property  short channelType
 @property  NSData *currentOutgoingRatchetState
 @property  NSDate *dateChannelCreated
 @property  BOOL decomissioned
 @property  NSString *identifier
 @property  NSData *membershipKey
 @property  NSData *peerKey
 @property  BOOL personal
 @property  NSString *presenceIdentifier
 @property  NSData *serverKey
 @property  NSString *statusType
 @property  NSSet *generatedEncryptionKeys
 @property  NSSet *invitedUsers
 @property  NSSet *receivedInvitations

  // class methods
  +[Channel fetchRequest]
  +[Channel identifierKeyPath]
  +[Channel predicateForChannelIdentifier:]
  +[Channel presenceIdentifierKeyPath]
  +[Channel predicateForStatusTypeIdentifier:]
  +[Channel predicateForPresenceIdentifier:]
  +[Channel personalKeyPath]
  +[Channel decomissionedKeyPath]
  +[Channel statusTypeKeyPath]
  +[Channel encryptionKeysKeyPath]
  +[Channel dateChannelCreatedKeyPath]
  +[Channel channelTypeKeyPath]
  +[Channel predicateForPersonal:]
  +[Channel predicateForDecomissioned:]
  +[Channel predicateForChannelTypeStatus]
  +[Channel predicateForChannelTypePresence]
  +[Channel predicateForCreationDateNotNil]
  +[Channel sortDescriptorForStatusTypeIdentifierOrderedAscending:]
  +[Channel sortDescriptorForPersonalOrderedAscending:]
  +[Channel sortDescriptorForChannelIdentifierOrderedAscending:]
  +[Channel sortDescriptorForCreationDateAscending:]


ChannelCheckpoint : NSManagedObject
 @property  NSString *channelID
 @property  long long checkpoint

  // class methods
  +[ChannelCheckpoint fetchRequest]
  +[ChannelCheckpoint identifierKeyPath]
  +[ChannelCheckpoint predicateForChannelIdentifier:]


GeneratedEncryptionKey : NSManagedObject
 @property  NSDate *dateGenerated
 @property  NSData *originalOutgoingRatchetState
 @property  Channel *channel

  // class methods
  +[GeneratedEncryptionKey fetchRequest]
  +[GeneratedEncryptionKey dateGeneratedKeyPath]


InvitedUser : NSManagedObject
 @property  NSDate *dateInvitationPayloadCreated
 @property  NSData *invitationPayload
 @property  NSString *invitedHandle
 @property  NSString *senderHandle
 @property  Channel *channel

  // class methods
  +[InvitedUser fetchRequest]
  +[InvitedUser senderHandleKeyPath]
  +[InvitedUser predicateForSenderHandle:]
  +[InvitedUser invitedHandleKeyPath]
  +[InvitedUser channelKeyPath]
  +[InvitedUser predicateForInvitedHandle:]
  +[InvitedUser predicateForChannel:]


PendingPublishRequest : NSManagedObject
 @property  NSDate *dateCreated
 @property  NSData *payloadData
 @property  int retryCount
 @property  NSString *statusTypeIdentifier
 @property  NSString *statusUniqueIdentifier

  // class methods
  +[PendingPublishRequest fetchRequest]
  +[PendingPublishRequest statusTypeIdentifierKeyPath]
  +[PendingPublishRequest predicateForStatusTypeIdentifier:]
  +[PendingPublishRequest dateCreatedKeyPath]
  +[PendingPublishRequest statusUniqueIdentifierKeyPath]
  +[PendingPublishRequest predicateForStatusUniqueIdentifier:]
  +[PendingPublishRequest sortDescriptorForDateCreatedAscending:]


ReceivedInvitation : NSManagedObject
 @property  NSData *channelToken
 @property  NSDate *dateInvitationCreated
 @property  NSData *incomingRatchetState
 @property  NSString *invitationIdentifier
 @property  NSData *invitationPayload
 @property  NSString *invitedHandle
 @property  NSData *peerKey
 @property  NSString *presenceIdentifier
 @property  NSString *senderHandle
 @property  NSData *serverKey
 @property  NSString *statusTypeIdentifier
 @property  Channel *channel

  // class methods
  +[ReceivedInvitation fetchRequest]
  +[ReceivedInvitation statusTypeIdentifierKeyPath]
  +[ReceivedInvitation predicateForStatusTypeIdentifier:]
  +[ReceivedInvitation dateInvitationCreatedKeyPath]
  +[ReceivedInvitation senderHandleKeyPath]
  +[ReceivedInvitation predicateForSenderHandle:]
  +[ReceivedInvitation predicateForSenderHandleString:]
  +[ReceivedInvitation sortDescriptorForDateInvitationCreatedOrderedAscending:]
  +[ReceivedInvitation sortDescriptorForSenderHandleOrderedAscending:]


RemovedUser : NSManagedObject
 @property  NSDate *dateRemoved
 @property  NSString *presenceIdentifier
 @property  NSString *removedHandle
 @property  NSString *statusTypeIdentifier

  // class methods
  +[RemovedUser fetchRequest]
  +[RemovedUser predicateForHandle:]
  +[RemovedUser dateRemovedKeyPath]
  +[RemovedUser handleKeyPath]
  +[RemovedUser statusTypeIdentifierKeyPath]
  +[RemovedUser presenceIdentifierKeyPath]
  +[RemovedUser predicateForHandleString:]
  +[RemovedUser predicateForStatusTypeIdentifier:]
  +[RemovedUser predicateForPresenceIdentifier:]


Status : NSManagedObject
 @property  NSString *channelIdentifier
 @property  NSDate *dateCreated
 @property  NSDate *dateExpired
 @property  NSDate *datePublished
 @property  NSDate *dateReceived
 @property  NSData *rawData
 @property  NSString *uniqueIdentifier

  // class methods
  +[Status fetchRequest]
  +[Status predicateForChannelIdentifier:]
  +[Status channelIdentifierKeyPath]
  +[Status dateCreatedKeyPath]
  +[Status predicateForStatusUniqueIdentifier:]
  +[Status sortDescriptorForDateCreatedAscending:]
  +[Status datePublishedKeyPath]
  +[Status uniqueIdentifierKeyPath]
  +[Status sortDescriptorForDatePublishedAscending:]


SubscriptionAssertion : NSManagedObject
 @property  NSString *applicationIdentifier
 @property  NSString *channelIdentifier
 @property  NSString *statusTypeIdentifier

  // class methods
  +[SubscriptionAssertion fetchRequest]
  +[SubscriptionAssertion predicateForChannelIdentifier:]
  +[SubscriptionAssertion channelIdentifierKeyPath]
  +[SubscriptionAssertion statusTypeIdentifierKeyPath]
  +[SubscriptionAssertion predicateForStatusTypeIdentifier:]
  +[SubscriptionAssertion applicationIdentifierKeyPath]
  +[SubscriptionAssertion predicateForApplicationIdentifier:]


TransientSubscriptionHistory : NSManagedObject
 @property  NSString *channelIdentifier
 @property  NSDate *lastSubscriptionDate

  // class methods
  +[TransientSubscriptionHistory fetchRequest]
  +[TransientSubscriptionHistory predicateForChannelIdentifier:]
  +[TransientSubscriptionHistory lastSubscriptionDateKeyPath]
  +[TransientSubscriptionHistory channelIdentifierKeyPath]
  +[TransientSubscriptionHistory predicateForLastSubscriptionDate:]
  +[TransientSubscriptionHistory sortDescriptorForLastSubscriptionDateAscending:]


(StatusKitAgent)
	// instance methods
	-[(StatusKitAgent) ska_dictionaryForKey:]
	-[(StatusKitAgent) ska_dataFrombase64EncodedStringForKey:]
	-[(StatusKitAgent) ska_dateFromUnixTimestampForKey:]
	-[(StatusKitAgent) ska_stringForKey:]
	-[(StatusKitAgent) ska_numberForKey:]

SKHandle(StatusKitAgent)
	// instance methods
	-[SKHandle(StatusKitAgent) idsDestination]
	-[SKHandle(StatusKitAgent) normalizedHandleString]
	-[SKHandle(StatusKitAgent) isNormalizedEqualToHandle:]

NSXPCConnection(StatusKitAgent)
	// instance methods
	-[NSXPCConnection(StatusKitAgent) sk_stringArrayValueForEntitlement:]
	-[NSXPCConnection(StatusKitAgent) sk_booleanValueForEntitlement:]
	-[NSXPCConnection(StatusKitAgent) sk_stringValueForEntitlement:]

(StatusKitAgent)
	// instance methods
	-[(StatusKitAgent) ska_hexString]

(StatusKitAgent)
	// instance methods
	-[(StatusKitAgent) ska_appearsToBeEmail]
	-[(StatusKitAgent) ska_sha256Hash]

01 00 0800 /System/Library/Frameworks/Accounts.framework/Accounts: ACAccountStore 
01 00 0a00 /System/Library/PrivateFrameworks/AuthKit.framework/AuthKit: AKAppleIDAuthenticationContext 
01 00 0a00 /System/Library/PrivateFrameworks/AuthKit.framework/AuthKit: AKAppleIDAuthenticationController 
01 00 0500 /System/Library/PrivateFrameworks/ApplePushService.framework/ApplePushService: APSConnection 
01 00 0e00 /System/Library/PrivateFrameworks/BiomeStreams.framework/BiomeStreams: BMStreams 
01 00 0e00 /System/Library/PrivateFrameworks/BiomeStreams.framework/BiomeStreams: BMUserStatusChangeEvent 
01 00 0900 /System/Library/Frameworks/CloudKit.framework/CloudKit: CKContainer 
01 00 0900 /System/Library/Frameworks/CloudKit.framework/CloudKit: CKContainerID 
01 00 0600 /System/Library/PrivateFrameworks/FTServices.framework/FTServices: FTMessageDelivery_APS 
01 00 0600 /System/Library/PrivateFrameworks/FTServices.framework/FTServices: FTProtobufMessage 
01 00 0600 /System/Library/PrivateFrameworks/FTServices.framework/FTServices: FTShareChannelMessage 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSIDQueryController 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSServerBag 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSService 
01 00 0700 /System/Library/PrivateFrameworks/IDS.framework/IDS: IDSURI 
01 00 0d00 /System/Library/PrivateFrameworks/MessageProtection.framework/MessageProtection: MPStatusKitIncomingRatchet 
01 00 0d00 /System/Library/PrivateFrameworks/MessageProtection.framework/MessageProtection: MPStatusKitOutgoingRatchet 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSArray 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSBundle 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSCompoundPredicate 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSConstantArray 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSConstantIntegerNumber 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSData 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSDate 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSDictionary 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSError 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSFetchRequest 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSFileManager 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSHashTable 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSJSONSerialization 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSKeyedArchiver 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSKeyedUnarchiver 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSManagedObject 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSManagedObjectModel 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSMapTable 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableArray 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableData 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableDictionary 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSMutableIndexSet 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableOrderedSet 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSMutableSet 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSMutableString 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSNotificationCenter 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSNumber 
01 00 1100 /usr/lib/libobjc.A.dylib: NSObject 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentCloudKitContainer 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentCloudKitContainerOptions 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentHistoryChangeRequest 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentHistoryToken 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentHistoryTransaction 
01 00 0200 /System/Library/Frameworks/CoreData.framework/CoreData: NSPersistentStoreDescription 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSPredicate 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSPropertyListSerialization 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSSet 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSSortDescriptor 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSString 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSUUID 
01 00 1300 /System/Library/Frameworks/CoreFoundation.framework/CoreFoundation: NSUserDefaults 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSXPCConnection 
01 00 1000 /System/Library/Frameworks/Foundation.framework/Foundation: NSXPCListener 
01 00 0300 /System/Library/PrivateFrameworks/ProtocolBuffer.framework/ProtocolBuffer: PBCodable 
01 00 0300 /System/Library/PrivateFrameworks/ProtocolBuffer.framework/ProtocolBuffer: PBRequest 
01 00 0400 /System/Library/Frameworks/PushKit.framework/PushKit: PKPublicChannel 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKHandle 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKHandleInvitability 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKInvitationPayload 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKPresenceDaemonConnection 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKPresentDevice 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKPublishedStatus 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusPayload 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusPublishRequest 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusPublishingDaemonConnection 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusSubscriptionDaemonConnection 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKStatusSubscriptionMetadata 
01 00 0100 /System/Library/PrivateFrameworks/StatusKit.framework/StatusKit: SKSubscriptionValidationTokens 
